%------------------------------------------------------------------------------
% Copyright (c) !!COPYRIGHTYEAR!!, Xavier Leroy and Didier Remy.
%
% All rights reserved. Distributed under a creative commons
% attribution-non-commercial-share alike 2.0 France license.
% http://creativecommons.org/licenses/by-nc-sa/2.0/fr/
%
% Translation by Till Varoquaux
%------------------------------------------------------------------------------

\chapter{Modern communication: sockets}
\label{sec/sockets}
\cutname{sockets.html}

Communication using pipes can be somewhat lacking. It is local to a machine:
communicating processes must run on the same machine (when using named pipes)
or even share the pipe's creator as a common ancestor (when using anonymous
pipes). Furthermore pipes are not very suitable for a very useful model of
communication: the connected or client-server model. In this model only one
program (the server) has direct access to a shared resource; the other programs
(the clients) access the res-source through a shared connection with the server;
the server serializes and controls those accesses. (e.g. The \textsc{x}-window
windowing system ~---~ the shared resources here being the screen, the keyboard
and the mouse.) The client-server model is hard to implement with pipes. The
problem being establishing the connection between a client and the server. With
anonymous pipes it is impossible: it would require for the server and the client
to have a common ancestor. With named pipe one could imagine that the server
would read connection requests on a given named pipe, these requests could carry
the name of another named pipe then used to talk directly to the client. The
issue is ensuring mutual exclusion between simultaneous connection requests.

Sockets are a generalization of pipes addressing these issues. The client server
model (in connected mode) is described in figure~\ref{fig/client-server}.

\begin{myfigure}
\begin{myimage}[width="70\%"]
\begin{tikzpicture}
[port/.style={draw,fill,circle,minimum size=1mm,inner sep=0mm},
 server/.style={draw, rectangle, inner sep=2mm,rounded corners},
 client/.style={draw, ellipse}]
\node (V) at (0,4) [server] {Server $V$};
\node (Vp1) at (V.-8) [port] {};
\node (Vp2) at (V.8) [port] {};
\node (U) at (-1,2) [server] {Server $U$};
\node (Up1) at (U.-8) [port] {};
\node[below right] at (Up1.east) {(1)}; % because of babel french

\node (Up2) at (U.8) [port] {};

\node (W) at (0,0) [server] {Server $W$};
\node (Wp1) at (W.-8) [port] {};
\node (Wp2) at (W.8) [port] {};

\node (A) at (5,3) [client] {Client $A$};
\node (Ap) at (A.west) [port] {};

\node (B) at (5,1) [client] {Client $B$};
\node (Bp) at (B.west) [port] {};

\draw [<->] (Up1) to [bend right=15] node[below]{(2)} (Ap);
\draw [<->,dashed] (Up2) to [bend left=15] node[above]{(3)} (Ap);

\draw [<->] (Vp2) to [bend left=20] node[above]{(5)} (Ap);
\draw [<->] (Wp2) to [bend right=20] node[below]{(6)} (Bp);
\draw [densely dotted] (U.north) to [bend left=20] node[left]{(4)} (V.south);
\draw [densely dotted] (U.south) to [bend right=20] (W.north);
\end{tikzpicture}
\end{myimage}
\caption{Client-Server model}
\label{fig/client-server}
\end{myfigure}

\begin{enumerate}
\item
The server $U$ creates a socket $p$ on a port $p$ known from the clients and
waits for connections on it (1).
%
\item
The client $A$ creates a socket and connects to the server on the port
$p$~(2). The server then allocates a new socket to communicate privately with
the client $A$ (3). In the example given here the server forks off an auxiliary
server $v$~(4), closes his connection with the client $4$ (represented by the
hashed line) and lets its child $V$ handle the connection with $A$~(5).
%
\item
The server can then accept a new client $B$, establish a new connection handled
by a clone $w$~(6) and so on.
%
\item
The server can close his service by closing the file descriptor bound to the
socket $p$. After a while the system frees the port $p$ which can then be reused
(for instance to provide another service).

\end{enumerate}

In the model the server $U$ and the client $A$ must establish a private
connection (3) to communicate until the end of the connection without
interfering with other requests issued by other clients. Because of that this
mode is referred to as the \emph{connected} mode. If the transaction is short
the server could handle the request directly (without forking) through the
connection (3). In this case the next client must wait for the server to be
available either because it has finished handling connection (3) or because it
handles explicitly several connexions via multiplexing.

Sockets also allow a disconnect \emph{disconnect} client-server mode (although
it is less frequently used). In this mode instead of establishing a private
connection with the client the server answers directly to the client's
requests. Section~\ref {sec/mode-deconnecte} gives and overview of this
model. In the remaining of this chapter we shall mostly detail the
\emph{connected} mode.

\section{Sockets}

The socket mechanism, which is an extension of the pipe mechanism, was
introduced in \textsc{bsd} 4.2 and can now be found in virtually every network
connected Unix machine (whether via Ethernet or some other medium). First,
special system calls are provided to establish connections in the client-server
model. Then sockets enable local and remote inter-process communication in a
(nearly) transparent way. Several communication domains are considered. The
communication domain bound to a socket indicates with whom we can communicate on
that socket ; it conditions the format of the address used on that socket. Two
examples of domains:

\begin{itemize}
\item the Unix domain: addresses are names in the file system
  hierarchy  of a machine. Communication is limited to processes
  running on that machine (like with named pipes).
%
\item 
the Internet domain: addresses are made of the address of a machine on the
Internet network (i.e. \ml+129.199.129.1+) and a service number on that
machine. Communication is possible between running on any two machines connected
to Internet. \footnote{ the Internet network is made of local networks, usually
  Ethernet networks connected by specialized links. It connects millions of
  machines in the whole wide word. On the Internet there machines can
  communicate to a neighbor machine connected to the same cable just the same
  as to one on the other side of the planet through tens of routers and a
  satellite.}
\end{itemize}
%
Finally several communication semantics are handled. These semantic amongst
other things, indicate whether the communication is reliable (no loss nor
duplication of data) and which form the data is sent as (byte flux or packet
flux ~---~small delimited blocks of bytes). The semantic conditions the protocol
used to transmit data. Here are three examples of possible semantics:
%
\smallskip
\begin{center}
\begin{tabular}{l|lll}
         & Flux & Datagram & Segmented packets \\
\hline
Reliable   & yes    & no       & yes \\
Representation of the data & byte flux & packets & packets \\
\end{tabular}
\end{center}
\smallskip


\quotes{flux} semantic is really close to the one in pipe
communication. It is the most widespread semantic  specifically when
transmitted unstructured byte sequences (\emph{e.g.} \ml+rsh+).
\quotes{Structured packets} semantic splits the transmitted data in
packets: each write delimits a packet, each read reads at most a
packet. It is well suited to message based
communication. \quotes{Datagram} is the closest to the hardware specs
of an Ethernet network: transmissions are packet based but there is no
guaranty packets arrive at destination. It is the most economical in
terms of network load. Some programs use it to transmit non crucial
data ({\emph{e.g.} \ml+biff+}); others to have a lighter network
footprint given. They must deal with data loses on there own.

%
\section{Socket creation}

The \syscall{socket} system call creates a new socket:
%
\begin{codefile}{tmpunix.mli}
type socket_domain = Unix.socket_domain
type socket_type = Unix.socket_type
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{socket}$ : socket_domain -> socket_type -> int -> file_descr
\end{listingcodefile}
%
The result is a file descriptor representing the new socket. This descriptor is
originally in \quotes{non-connected} mode. In this state it not ready to accept
any \ml+read+ or \ml+write+.

The first argument is the communication domain to which the socket is bound:
%
\begin{mltypecases}
\mltypecase{PF\_UNIX} the Unix domain
\mltypecase{PF\_INET} the Internet domain
\end{mltypecases}
%
The second argument is the desired communication semantic:
%
\begin{mltypecases}
\mltypecase{SOCK\_STREAM} byte streams, reliable
\mltypecase{SOCK\_DGRAM}  packets, unreliable
\mltypecase{SOCK\_RAW} direct access to the lower level layer of the network
\mltypecase{SOCK\_SEQPACKET} packets, reliable
\end{mltypecases}
%
The third argument is the number of the communication protocol to use. It is
generally 0 which is the default protocol usually inferred from the
communication type (\ml+SOCK_DGRAM+ and \ml+SOCK_STREAM+ are usually associated
with the \textsc{udp} and \textsc{tcp} protocols).  Other values give access to
special protocols. For instance : the \textsc{icmp} (\emph{Internet Control
  Message Protocol}) protocol which is the protocol used by the \ml+ping+ to
send packets with automatic return to sender. The protocol numbers are set in
the file: \ml+/etc/protocols+ or in the \ml+protocols+ of the \textsc{nis}
(\emph{Network Information Service}) information system. The
\syscall{getprotobyname} system call enables to read this table in a portable
way:
%
\begin{codefile}{tmpunix.mli}
type protocol_entry = Unix.protocol_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{getprotobyname}$ : string -> protocol_entry
\end{listingcodefile}
%
the argument is the name of the desired protocol. The result is a \emph{record}
with \ml+p_proto+ which is the number of the protocol.

\section{Addresses}

Several socket operations use socket addresses. They are value of concrete type
\ml+sockaddr+:
\begin{lstlisting}
type $\libtype{Unix}{sockaddr}$ =
  | ADDR_UNIX of string
  | ADDR_INET of inet_addr * int
\end{lstlisting}
The \ml+ADDR_UNIX f+ address is an address in the Unix domain. The string \ml+f+
is the name of the corresponding file in the computer's file system.

\ml+ADDR_INET (a,p)+ is an address in the Internet domain. The first argument,
\ml+a+, is the Internet address of a machine. The second argument, \ml+p+, is a
service number (\emph{port number}) in this machine.

Internet addresses are represented by the abstract type \ml+inet_addr+. There
are two functions enabling to convert strings like \ml+128.93.8.2+ between
\ml+inet_addr+ and reciprocally:
%
\begin{codefile}{tmpunix.mli}
type inet_addr = Unix.inet_addr
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{inet\_addr\_of\_string}$ : string -> inet_addr
val $\indexlibvalue{Unix}{string\_of\_inet\_addr}$ : inet_addr -> string
\end{listingcodefile}
%

Another way to obtain Internet addresses is by consulting the \ml+/etc/hosts+
table. This file binds Internet addresses to machine names. This file as well as
the \textsc{nis} table. Can be consulted via the \syscall{gethostbyname} system
call. On modern machines, this functions queries the \quotes{name servers}
either as a fallback or, contrarily, using the file \ml+/etc/hosts+ as a last
resort.
%
\begin{codefile}{tmpunix.mli}
type host_entry = Unix.host_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{gethostbyname}$ : string -> host_entry
\end{listingcodefile}
%
The argument is the name of the desired machine. The result is an \emph{record}
having a \ml+h_addr_list+ field which is an array of Internet addresses: the
addresses of the machine. (The same machine can be connected to different
networks under different addresses.)

The most commons service number (\emph{port numbers}), are referenced in the
\ml+/etc/services/+. It can be read in portable way using the
\syscall{getservbyname} system call~:
%
\begin{codefile}{tmpunix.mli}
type service_entry = Unix.service_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{getservbyname}$ : string -> string -> service_entry
\end{listingcodefile}
%
The first argument is the service name (ie, \ml+ftp+ for FTP servers, \ml+smtp+
for emails, \ml+nntp+ for News server, \ml+talk+ and \ml+ntalk+ for the talk and
ntalk commands). The second argument is the protocol's name: usually \ml+"tcp"+
if the service is using \quotes{stream} semantic or \ml+"udp"+ if the service
uses \quotes{datagrams}' semantic. The result of \ml+getservbyname+ is a record
which \ml+s_port+ field contains the desired number.


\begin{example} To obtain the address of:
\ml+pauillac.inria.fr+~:
%
\begin{lstlisting}
ADDR_INET((gethostbyname "pauillac.inria.fr").h_addr_list.(0),
          (getservbyname "ftp" "tcp").s_port)
\end{lstlisting}
\end{example}

\section{Connection to a server}

The \syscall{connect} system call establishes a connection with a server at a
given address.
%
\begin{codefile}{tmpunix.mli}
type sockaddr = Unix.sockaddr
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{connect}$ : file_descr -> sockaddr -> unit
\end{listingcodefile}
%
The first argument is a socket descriptor. The second argument is the address of
the server to which we want to connect.

Once the connection is established one can send data to the server using
\indexvalue{write} on the socket descriptor and data originating from the server
with \indexvalue{read}. Sockets behave the same as pipes for read and write
operations: \ml+read+ blocks if no data is available and can return less bytes
than requested, if the server closes the connection \ml+read+ returns 0 and
\ml+write+ raises a \ml+SIGPIPE+ signal.

\ml+connect+ binds the socket to a local address chosen by the system. Sometimes
it is preferable to manually chose this address in which case one can call the
\ml+bind+ function before \ml+connect+.

The \ml+netstat+ connection can be used to monitor current connections in the
shell.

\section{Disconnection}

There are two ways to interrupt an established connection. The first is to call
\indexvalue{close} on the socket, This closes the read and write sides of the
connection and de-allocates the socket. The behavior is sometimes too
brutal. For instance a client might want to close the connection in the client
to server direction in order to indicate the end of file to the server but still
keep the connection open on the reading side so that the server can keep on
sending data. The \syscall{shutdown} system call enable shutting down just one
side of the connection.
%
\begin{codefile}{tmpunix.mli}
type shutdown_command = Unix.shutdown_command
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{shutdown}$ : file_descr -> shutdown_command -> unit
\end{listingcodefile}
%
The first argument is the descriptor of the socket to close. The second argument
is one of:
\begin{mltypecases}
\mltypecase{SHUTDOWN\_RECEIVE} Closes the read side of the socket; \ml+write+
on the server side will raises a \ml+SIGPIPE+ signal.

\mltypecase{SHUTDOWN\_SEND} closes the read side of a socket; \ml+read+ on the
server side returns end of file.

\mltypecase{SHUTDOWN\_ALL} closes the read and the write sides of the
socket. Unlike with \ml+close+, the socket itself is not de-allocated.
\end{mltypecases}
De allocation can be a lengthy operation whether done brutally or not.


\section{Complete example: The universal client}

We are going to define a \ml+client+ such that \ml+client host port+ establishes
a connection with a service numbered \ml+port+ on the machine named \ml+host+,
than sends on the connections everything it reads from its standard in and
writes on its standard out everything it receives on the connection.

For instance the command
\begin{lstlisting}
echo -e 'GET /~remy/ HTTP/1.0\r\n\r\n' | ./client pauillac.inria.fr 80
\end{lstlisting}
connects to the port \ml+80+ of the \ml+paulliac.inria.fr+ and sends the
\ml+HTTP+ command requesting the home page \ml+/~remy/+ on this server.

This command is an \quotes{universal} client because it factors out the
connection establishing code common to many clients while delegating the
protocol specific part to the caller.

We use a library call \ml+retransmit+ copying data from one descriptor to
another. It terminates when the end of file is reached on the input
descriptor. \ml+retransmit+ can still be interrupted by a signal.
\begin{codefile}{misc.mli}
val retransmit : file_descr -> file_descr -> unit
(** [retransmit fdin fdout] copy the contain of fdin into fdout, until
it receives end of file in fdin. It does not close descriptors at the
end *)
\end{codefile}
\begin{listingcodefile}{misc.ml}
let retransmit fdin fdout =
  let buffer_size = 4096 in
  let buffer = String.create buffer_size in
  let rec copy() =
    match read fdin buffer 0 buffer_size with
      0 -> ()
    | n -> ignore (write fdout buffer 0 n); copy() in
  copy ();;
\end{listingcodefile}
Serious things start here.
\begin{listingcodefile}[style=numbers]{client.ml}
open Sys;;
open Unix;;

let client () =
  if Array.length Sys.argv < 3 then begin
    prerr_endline "Usage: client <host> <port>";
    exit 2;
  end;
  let server_name = Sys.argv.(1)
  and port_number = int_of_string Sys.argv.(2) in
  let server_addr =
    try (gethostbyname server_name).h_addr_list.(0)
    with Not_found ->
      prerr_endline (server_name ^ ": Host not found");
      exit 2 in
  let sock = socket PF_INET SOCK_STREAM 0 in
  connect sock (ADDR_INET(server_addr, port_number));
  match fork() with
  | 0 -> $\label{prog:add_signal_ignore}$
      Misc.retransmit stdin sock;
      shutdown sock SHUTDOWN_SEND;
      exit 0
  | _ ->
      Misc.retransmit sock stdout;
      close stdout;
      wait();;

handle_unix_error client ();;
\end{listingcodefile}

We start be figuring the Internet address of the server to which we want to
connect. It can be passed (as the first argument of the command) either as a
string or a number. The \ml+gethostbyname+ handles correctly both cases. In the
case of a symbolic address the \ml+/etc/hosts+ table is queried and the first
satisfying entry is returned. When a numerical address is given no checks are
performed: a structure is simply allocated for the requested entry.

After, a socket on the Internet domain is created with \quotes{stream} semantic
end the default protocol and we connect it to the requested address.

The process is then clone via a \ml+fork+ call. The son process copies the data
on its standard in to the socket. Once the end of the data on the standard in is
reached it closes the write side of the connection thus transmitting an
\quotes{end of file} to the server and shuts down. The father process copies the
data read on the socket to its standard out. Once the end of the file is reached
on the socket it \ml+wait+s for the child process and exits.

Closing the connection can be done at the client's or the server's initiative.
\begin{itemize}

\item
The client receives the end of file on its standard in. The client (son) then
closes the connection in the client/server direction and exits. The server upon
receiving the end of file on the connection should, after a small amount of
processing, close the connection. Finally on the other end of \ml+sock+ the
client (father) receives end of file on the connection and terminates normally.

\item
The server closes prematurely the connection. The client (father) tries to write
on the socket \ml+sock+ and receives the \ml+sigpipe+ signal which kills it. It
is the expected semantic. However the client dies immediately without being able
to indicate that the connection was interrupted. This information can be
retrieved by ignoring the \ml+SIGPIPE+ signal thus returning the \ml+EPIPE+
which will than be handled by the handler \ml+handle_unix_error+: one must
insert the following code right after the line~\ref{prog:add_signal_ignore}.
%
\begin{lstlisting}
ignore (signal sigpipe Signal_ignore)
\end{lstlisting}
%
\end{itemize}
If the client, father or son, exits prematurely the socket will be closed in
read or write mode. Upon receiving this information the server will close its
side of the socket which will in turn be detected by the other part of the
client. Otherwise the server exit normally and closes the connection. In both
cases we end up in one of the previous scenarios.


\section{Establishing a service}

We have just seen how a client connects to a server, we shall now see how things
works on the server side. The first step is to tie an address to a socket, thus
making it reachable from the outside. It is the role of the system call
\syscall{bind}: 
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{bind}$ : file_descr -> sockaddr -> unit
\end{listingcodefile}
%
The first argument is the descriptor of the socket; the second is the address to
attribute to it. The \ml+bind+ command can also use a special address
\ml+inet_addr_any+ representing all the available Internet addresses on the
machine (which can have several sub-networks).

We then declare that the socket can accept connections via the system call
\syscall{listen}:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{listen}$ : file_descr -> int -> unit
\end{listingcodefile}
%
The first argument is the socket descriptor. The second indicates how many
incomplete connections can be put on hold. This value, usually of the order
several dozens can go up to several hundreds for very busy servers. When this
number is exceeded additional connection request fail.

Connection requests are received via the system call
\syscall{accept}:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{accept}$ : file_descr -> file_descr * sockaddr
\end{listingcodefile}
% 
The argument is the socket descriptor. The first part of result is a descriptor
on a newly created socket connected to the client: everything written on this
descriptor can be read on the socket that was given by the client as argument to
\ml+connect+ and reciprocally. On the server side the socket passed as an
argument to \ml+accept+ stays free and can accept more connection requests. The
second part of the result is the client's address. It can be used to to check
that the client is authorized to connect to this server (the \textsc{x} server
for instance uses the clients address for authorization. \ml+xhost+ can be used
to change this authorization) or to establish a second connection from the
client to the server (\ml+ftp+ does this for each file demand).

The general scheme of a \textsc{tcp} is of the form (we define these functions
in the \ml+Misc+ library).

%
\begin{codefile}{misc.mli}
val install_tcp_server_socket : Unix.sockaddr -> Unix.file_descr
(** [install_tcp_server_socket sockaddr] creates a socket in the internet
 domain,  binds it to the address [sockaddr], listens to it, and returns
it. *)

val tcp_server :
 (file_descr -> file_descr * sockaddr -> 'a) -> sockaddr -> unit
(** [tcp_server f addr] installs the tcp service [f] at the Internet domain
   address  [addr]. For each connection to the service, the
   function [f] receives the server's socket and the client's
   socket-address pair as parameters. It is the responsibility of  [f] to
   close the client connection when done. *)
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{misc.ml}
let install_tcp_server_socket addr =
  let s = socket PF_INET SOCK_STREAM 0 in $\label{prog:sock_stream}$
  try
    bind s addr; $\label{prog:bind}$
    listen s 10; $\label{prog:listen}$
    s
  with z -> close s; raise z;;

let tcp_server treat_connection addr =
  ignore (signal sigpipe Signal_ignore);
  let server_sock = install_tcp_server_socket addr in
  while true do
      let client = restart_on_EINTR accept server_sock in $\label{prog:accept}$
      treat_connection server_sock client $\label{prog:treat}$
  done;;
\end{listingcodefile}
The function \ml+install_tcp_server+ starts by creating a socket on the Internet
domain with the \quotes{stream} semantic and the default protocol
(line~\ref{prog:sock_stream}), it then prepares it to accept new connection
requests on the \emph{port} passed as an argument on the command line by the
\ml+bind+ and \ml+listen+ calls on the lines~\ref{prog:bind}
and~\ref{prog:listen}. Given that this is a library function we close the socket
cleanly in case of an error in the \ml+bind+ or \ml+listen+ operations.

The \ml+tcp_server+ function creates the socket with \ml+install_tcp_server+ and
enter an infinite loop. In each iteration, it waits for a connection request
(\ml+accept+, line ~\ref{prog:accept}) and handles it
(line~\ref{prog:treat}). Since this is a library function we relaunch the
(blocking) \ml+accept+ system call if it is interrupted. It is
\ml+treat_connection+'s duty to close the \ml+client+ descriptor once the
connection end (even when it is brutally interrupted). We ignore the
\ml+sigpipe+ signal which could be triggered by an unexpected disconnection of
the client. Such an event raises an \ml+EPIPE+ exception which can be caught by
\ml+treat_connection+ rather than brutally killing the process.


The \ml+treat_connection+ function also takes the server descriptor as argument
because in case of a \ml+fork+ or \ml+double_fork+ it will need to be closed by
the forked child.

Handling connections can be done sequentially. \ie{} by the server. In which
case \ml+treat_connection+ just calls the \ml+service+ function. This function
is specific to the application and represents the main loop of the server
providing the requested service. It ends by closing the connection.
%
\begin{lstlisting}
let service (client_sock, client_addr) =
  (* Handle the client on the descriptor client_sock *)
  (* And when we are done: *)
  close client_descr;;
\end{lstlisting}
%
We therefore add the following function to the \ml+Misc+ library:
\begin{codefile}{misc.mli}
val sequential_treatment :
file_descr -> (file_descr * sockaddr -> unit) ->
file_descr * sockaddr -> unit
(** [sequential_treatment server service client] runs [service] provided
      on server for one client. The server is given by its socket [socket]
      and the client is given by its socket-address pair [client]. After
      initialization the service is performed by applying [service] to
      [client]. The treatment is sequential, that is, the function only
      returns when the service is completed. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let sequential_treatment server service client = service client
\end{listingcodefile}

In this schema the server cannot handle any other requests while serving a
client. It is usually reserved for quick services where the \ml+service+
function always runs in a short bounded time. (for instance a \ml+date+ server).

Most servers delegate the service to a child sub-process: \ml+fork+ is called
immediately after \ml+accept+. The farther process starts calling \ml+accept+
straight away. The son process handle the connection. We obtain the following
library function~:
%
\begin{codefile}{misc.mli}
val fork_treatment :
 file_descr -> (file_descr * sockaddr -> unit) ->
 file_descr * sockaddr -> unit
(** same as [sequential_treament] but the treatment is concurrently
 performed by a forked child process of the server. The parent process
 will have to free the child when completed. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let fork_treatment server service (client_descr, _ as client) =
  let treat () = match fork () with
    | 0 -> close server; service client; exit 0
    | k -> ()
  in
  try_finalize treat () close client_descr;;
\end{listingcodefile}
%
The father must close the \ml+client_descr+ otherwise closing it in the child
will not terminate the connection. Also the father will eventually out of
descriptor. Closing the descriptor must happen even, fork fails~---~the program
can eventually decide this error is not fatal and carry on.

Symmetrically the child must close the \ml+sock+ descriptor on which the
connection request was received. For once it doesn't need it, furthermore the
server might stop accepting connections before the child is done handling this
connection. The child must stop running after it is done handling the current
connection otherwise it will run the server code. This what the \ml+exit 0+ is
here for.

We have glossed over the collection of children processes that will become
zombies. This must be done; and there are two ways to do so: the simple approach
is to have a grand-child handle the connection with a double fork.
%
\begin{codefile}{misc.mli}
val double_fork_treatment :
file_descr -> (file_descr * sockaddr -> unit) ->
file_descr * sockaddr -> unit
(** same as [fork_treament] but the treatment is performed after a double
   fork. The forked process will be freed automatically on
   completion. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let double_fork_treatment server service (client_descr, _ as client) =
  let treat () = match fork () with
    | 0 ->
        if fork () <> 0 then exit 0;
        close server; service client; exit 0
    | k ->
        ignore (restart_on_EINTR (waitpid []) k)
  in
  try_finalize treat () close client_descr;;
\end{listingcodefile}
%
However this approach takes away all control of the grand-child from the
server. In general it is best for the process handling a service to belong to
the same process group as the server. This enables to kill all the services by
killing the all the processes from that group. For this servers usually keep the
same model as before and add handling of the clients for instance by installing
a \ml+Misc.free_children+ handling to the \ml+sigchld+ signal.


\section {Sockets tuning}

Sockets have numerous internal parameters that can be tuned: the buffer's size,
the minimum transfers' size, the behavior on closing, \etc{} These parameters
are of types bool, int , int option, float. For typing reasons there are as many
\ml+getsockopt+, \ml+getsockopt_optint+, \ml+getsockopt_float+, to read those
parameters and as many variants of \ml+setsockopt+. One can read the
documentation of the \ocaml\libvalue{Unix}{getsockopt}~function and its variants
as well as the \textsc{posix} reference to the \syscall{getsockopt} system to
have a detailed list of those option.

For instance, here are two types of settings that only apply to sockets on the
\ml+INET+ domain of the \ml+SOCK_STREAM+ type. The disconnection of sockets in
the \textsc{tcp} protocol can take some time. Normally the \indexvalue{close}
returns straight away while the system is shutting down the connection.
%
\begin{lstlisting}
setsockopt_optint sock SO_LINGER (Some 5);;
\end{lstlisting}
%
This option turns \indexvalue{close} in a blocking operation on the
\ml+sock+. It blocks until all the data has been transmitted or until a 5 second
timeout has expired.
%
\begin{lstlisting}
setsockopt sock SO_REUSEADDR;;
\end{lstlisting}
%
The main effect of the \ml+SO_REUSEADDR+ is to enable the \indexvalue{bind} to
reallocate a socket on which the old connection is still being closed. There is
a risk of unexpected data coming in for the old connection. On the flip side
this option enables restarting a server in a short loop this is very useful to
run tests.

\section{Full example: the universal server}

We shall now define a \ml+server+ command such that:
%
\begin{lstlisting}
./server port cmd arg1 ... argn
\end{lstlisting}
%
Receives connection requests on the port \ml+port+ and, foreach of them,
dispatches \ml+cmd+ with the arguments \ml+arg1 ... argn+ and the connection
piped on its standard input and standard output. For instance if we type
%
\begin{lstlisting}
./server 8500 grep foo
\end{lstlisting}
%
on the \ml+pomerol+ machine we can now call on any machine
%
\begin{lstlisting}
./client pomerol 8500 < /etc/passwd
\end{lstlisting}
%
with the aforementioned \ml+client+ command and the it displays the same result
as if we had typed
%
\begin{lstlisting}
./grep foo < /etc/passwd
\end{lstlisting}
%
on \ml+pomerol+.

The \ml+server+ command is a universal server in as much as it factors in all
the service establishment code common to many servers whilst dispatching the
service and protocol specific part to the dispatched program.
%
\begin{listingcodefile}[style=numbers]{server.ml}
open Sys;;
open Unix;;

let server () =
  if Array.length Sys.argv < 2 then begin
    prerr_endline "Usage: client <port> <command> [arg1 ... argn]";
    exit 2;
  end;
  let port = int_of_string Sys.argv.(1) in
  let args = Array.sub Sys.argv 2 (Array.length Sys.argv - 2) in
  let host = (gethostbyname(gethostname())).h_addr_list.(0) in $\label{prog:gethost}$
  let addr = ADDR_INET (host, port) in
  let treat sock (client_sock, client_addr as client) =
    (* log information *)
    begin match client_addr with
    | ADDR_INET(caller, _) ->
        prerr_endline ("Connection from " ^ string_of_inet_addr caller);
    | ADDR_UNIX _ ->
        prerr_endline "Connection from the Unix domain (???)";
    end;
    (* connection treatment *)
    let service (s, _) =
      dup2 s stdin; dup2 s stdout; dup2 s stderr; close s;
      execvp args.(0) args
    in
    Misc.double_fork_treatment sock service client in
  Misc.tcp_server treat addr;;

handle_unix_error server ();;
\end{listingcodefile}
%
The address given to \ml+tcp_server+ contains the Internet address of the
machine running the program. The usual way to get it (line~\ref{prog:gethost})
is to look for the machine (returned by the \ml+gethostname+ call) in the
\ml+/etc/hosts+ table. There can be several addresses referencing the same
machine. For instance the address of the pauillac machine is \ml+128.93.11.35+,
but we can access it locally (provided we are running on this machine) via
\ml+127.0.0.1+. To provide a service on all the addresses pointing to this
machine we can use the \ml+inet_addr_any+ address.

The handling of the service will be done via a \quotes{double fork} after having
a basic handshake. The handling of the service is done by redirecting the
standard input and the two standard outputs to the socket on which the
connection was established and run the desired command. (Note that the handling
of the service cannot be done sequentially.)


The connection is closed without any intervention of the \ml+server+ program. In
the first case the client closes its connection towards the server. The command
dispatched by the server receives an end of file on its standard input. It
resumes running and calls \ml+exit+ when it is done. This close the standard
outputs which are the last descriptors open on the connection. The client will
then receive the end of file on the connection. Second case: The client ends
prematurely and closes the connection from the server. The server might the
receive the \ml+sigpipe+ signal while trying to open to send data to the client
which can them cause the death of the server side command. This is a perfectly
good behavior since nothing is reading the output of the command.

Finally the server command can exit (either by itself or via a signal) before
having read the end of file. The client receive a \ml+SIGPIPE+ signal (in which
case the client will die immediately) or an \ml+EPIPE+ exception (if the signal
is ignored) when it tries to read on the connection.

\subsection*{Precautions}

Writing a server is generally more delicate than a client. Whilst the client
knows the server to which it is connecting, the server ignores all from its
client. For public services the client might be \quotes{hostile}. The server
must guard itself against these pathological cases.

A classical attack is done by opening connections and leaving them opened
without transmitting any requests: after having accepted the connection the
server is stuck waiting on the socket and will stay this way while the client
stays connected. The attacker can then saturate the service by opening a lot of
connections. It is important for the server to be robust against such
attacks. On the one it must only accept a limited number of simultaneous
connections and refuse connections beyond that. This is done to avoid exhausting
system resources. It must also interrupt staled connections.

A sequential server handling the connection without handing it to son processes
is immediately exposed to this blocking issue: the server will be unresponsive
although it is idle. One way around on a sequential server is to multiplex the
connections but it is tricky to implement. The solution with parallel server is
more elegant but still needs to have a timeout. Such a timeout can be
implemented with an alarm.


\section{Communication in disconnected mode}
\label{sec/disconnected-mode}
\subsection*{Read/write in disconnected mode}

The \textsc{tcp} protocol is used by most connections of \ml+SOCK_STREAM+ can
only work in connected mode. Inversely the \textsc{udp} protocol used by most
connections in \ml+SOCK_DGRAM+ mode always work in disconnected mode. This means
there are now connections established between the two machines.

This type of socket can be used without establishing preliminary collection.
For this we use the \syscall{recvfrom} and \syscall{sendto} system call.
%
\begin{codefile}{tmpunix.mli}
type msg_flag = Unix.msg_flag
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{recvfrom}$ :
  file_descr -> string -> int -> int -> msg_flag list -> int * sockaddr

val $\libvalue{Unix}{sendto}$ :
  file_descr -> string -> int -> int -> msg_flag list -> sockaddr -> int
\end{listingcodefile}
%
Each of these calls return the size of the transferred data. The call
\ml+recvfrom+ also returns the address of the correspondent.

One can also call \indexvalue{connect} on a socket of type \ml+SOCK_DGRAM+. This
has no effect out of the local machine (we call it a pseudo-connection). The
local effect is to memorise the address passed as an argument and to restrict
communications to this address (messages coming in from another address are
ignored).

Socket of this type can be connected several times to change there target and
disconnected by connecting them to an invalid address (e.g. \ml+0+). (on a
socket of type \ml+SOCK_STREAM+ this would generally result in an error.

\subsection*{Low level read and writes}

The \syscall{recv} and \syscall{send} generalise the \indexvalue{read} and
\indexvalue{write} system calls. They only work on socket descriptors.
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{recv}$ : file_descr -> string -> int -> int -> msg_flag list -> int
val $\libvalue{Unix}{send}$ : file_descr -> string -> int -> int -> msg_flag list -> int
\end{listingcodefile}
%
There interface is similar to \ml+read+ and \ml+write+ but they also take a list
of flags with the following semantics:
%
\begin{mltypecases}
\mltypecase{MSG\_OOB} to send exceptional values

\mltypecase{MSG\_DONTROUTE} short circuit the default routing table

\mltypecase{MSG\_PEEK} queries the data without reading it.
\end{mltypecases}
%
Those primitives can be used in connected mode instead of \ml+read+ and
\ml+write+ or in pseudo connected mode instead of \ml+recvfrom+ and \ml+sendto+.
\section{High level primitives}

The example of the universal client-server is frequent enough that the \ml+Unix+
modules provides high order functions to establish services in a nearky
transparent way.
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{open\_connection}$ : sockaddr -> in_channel * out_channel
val $\indexlibvalue{Unix}{shutdown\_connection}$ : Pervasives.in_channel -> unit
\end{listingcodefile}
%
The \ml+open_connection+ function opens a socket at the given address and
creates a pair of channels (from the \ml+Pervasives+ module) for the input and
output on this socket. The communication with the server is done by writing
requests on the \ml+out_channel+ and by reading answers on the
\ml+in_channel+. Since channels are buffered we must flush the channels must in
order to ensure a request has run fully.
%
The client can shutdown the connection brutally by closing either of the channel
(which will close the socket) or more \quotes{politely} by calling
\ml+shutdown_connection+. If the server closes the connection the client will be
notified when it will read end-of-file on the \ml+in_channel+.

Symmetrically a service can be established with the \ml+establish_service+
function.
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{establish\_server}$ : 
  (in_channel -> out_channel -> unit) -> sockaddr -> unit
\end{listingcodefile}
%
This primitive takes a function \ml+f+, used to handle requests, and the address
of the socket on which the service is to be established as arguments. Each
connection to the server creates a new socket (as does the function
\ml+accept+); after being clone the child process creates a pair of channels
(from the \ml+Pervasives+ library) and passes them to the function \ml+f+ to
handle connections. The function \ml+f+ reads the requests on the opened
\ml+in_channel+ and answers on the \ml+out_channel+. Once the service has been
provided (i.e. once \ml+f+ has returned), the child process closes the socket
and exits. If the client closes the connection gently the child will get and end
of file on the \ml+in_channel+. If the client does it brutally the child might
receive a \ml+SIGPIPE+ while trying to write on the closed socket. The
\ml+establish_server+ usually never returns. It might exit in case of an error
(e.g. of the {\ocaml} runtime or while establishing the service).

\section{Exemples de protocoles}

In the simple cases (\ml+rsh+, \ml+rlogin+, \ldots), the data transmitted
between the client and the server are seen as byte streams, one from the client
to the server and the other from the client to the server. In other cases the
data to transmit is more complex and require to be coded before being
transmitted as a byte stream on the socket. The client and the server must then
agree on the transmission protocol. Most protocols used by Unix commands are
specified in documents called \quotes{\textsc{rfc}} (request for comments):
these documents start out as propositions open for discussion and become norms
as time goes by, as user adopt the described protocol.\footnote{\textsc{rfc} are
  available via anonymous \textsc{ftp} on numerous sites. In France:
  \href{ftp://ftp.inria.fr}{\texttt{ftp.inria.fr}}, in the directory
  \href{ftp://ftp.inria.fr/pub/rfc/}{\texttt{rfc}}. The reference site is
  \url{http://www.faqs.org/rfcs/}. }


\subsection*{\quotes{Binary} protocols}

The first family of protocol aims at transmitting the data in a compact form as
close as possible of there in memory representation in order to minimise the
work converting and to make the best of the available network bandwidth. Typical
examples of protocol of this type are: the \textsc{x}-window protocol which is
used to between the \textsc{x} server and the \textsc{x} applications, and the
\textsc{nfs} protocol (\rfc{1094}).

Integers or floating point numbers are usually transmitted as the 1,2,4 or 8
bytes of there binary representation. For strings we send the length of the
string first and then the byte content of the string. For structured objects
(tuples,records), we send the fields in order by concatenating there
representation. For objects of variable sizes (arrays) we send the number of
elements beforehand. The client can easily recreate in memory the structure of
the transmitted data provided it knows exactly the type of the transmitted
data. When several types of data are liable to be exchanged on a socket it is
often agreed to send an integer identifying the type of data following.

\begin{example}
The \ml+XFillPolygon+ call of the \textsc{x} library, which draws and colors the
polygon, sends message to the \textsc{x} server of the following structure:
\begin{itemize}
\item the byte 69 (the code of the \ml+FillPoly+ command)
\item a byte for padding
\item a 16 bit int: the number $n$ of vertices of the polygon
\item a 32 bit integer identifying the window on which we will draw the
  polygon.
\item a 32 bit integer identifying the \quotes{graphic context}
\item a \quotes{form} byte, identifying whether the polygon is convex etc.
\item a byte indicating whether the coordinates of the vertices's are absolute or
  relative.
\item $4n$ bytes coding the coordinates of the polygon's vertices, two 16 bits
  integer for each vertex
\end{itemize}
\end{example}

In this type of protocol one must be cautious of architecture differences
between the communicating machines. One specific case to lookout for is multi
byte integer: some machines put the most significant byte first (that is in the
lower-address in memory) (these architecture are called \emph{big-endian}),
others put the least significant byte first (we then talk about
\emph{little-endian} architectures). For instance the 16 bits integer $12345 =
48 \times 256 + 57$ is represented by the byte $48$ at the address $n$ and the
byte $57$ at the address $n+1$ on a big-endian architecture and by the byte $57$
at the address $n$ and the byte $48$ at the address $n+1$ on a little endian
architecture. The protocol must specify the endianess (big or little) used to
transmit integers. Another possibility is to let the emitter choose freely
between big-endian and little-endian and have it specify in the header of the
message which convention it will use.

The {\ocaml} system helps this data transformation (often call
\emph{marshalling} or \emph{serialization}) by providing two primitives to
convert an {\ocaml} value in of series of byte and conversely:
%
\begin{listingcodefile}{tmppervasives.mli}
val $\indexlibvalue{Pervasives}{output\_value}$ : out_channel -> 'a -> unit
val $\indexlibvalue{Pervasives}{input\_value}$ : in_channel -> 'a
\end{listingcodefile}
%
The aim of those two primitives is to enable writing out any structured object
to the disk and to read it back in. They also work well to transmit any objects
through a pipe or a socket.These can handle any kind of {\ocaml} object except
for functions. They preserve sharing and circularity inside transmitted objects
and they work between architectures of different \emph{endianness}.

\begin{example}
If \textsc{x}-window were written in {\ocaml}, we would have a concrete type
\ml+request+ representing requests that can be sent to the server and another
concrete type \ml+reply+ of eventual answers:
%
\begin{lstlisting}
type request =
    ...
  | FillPolyReq of (int * int) array * drawable * graphic_context
                                    * poly_shape * coord_mode
  | GetAtomNameReq of atom
  | ...
and reply =
    ...
  | GetAtomNameReply of string
  | ...
\end{lstlisting}
%
The core of the server would be a reading loop looking like:
%
\begin{lstlisting}
(* Get a connection request on the descriptor s *)
let requests = in_channel_of_descr s
and replies  = out_channel_of_descr s in
try
  while true do
    match input_value requests with
        ...
      | FillPoly(vertices, drawable, gc, shape, mode) ->
          fill_poly vertices drawable gc shape mode
      | GetAtomNameReq atom ->
          output_value replies (GetAtomNameReply(get_atom_name atom))
      | ...
  done
with End_of_file ->
  (* en of the connection *)
\end{lstlisting}
%
The \textsc{x} library, linked with each application would be like:
%
\begin{lstlisting}
(* Establish a connection with the server s *)
let requests = out_channel_of_descr s
and replies  = in_channel_of_descr s;;
let fill_poly vertices drawable gc shape mode =
  output_value requests
               (FillPolyReq(vertices, drawable, gc, shape, mode));;
let get_atom_name atom =
  output_value requests (GetAtomNameReq atom);
  match input_value replies with
    GetAtomNameReply name -> name
  | _ -> fatal_protocol_error \ml+get_atom_name+;;
\end{lstlisting}
\end{example}

Note the type of \ml+input_value+ given above is semantically incorrect because
it is too general: it is not true that the result of \ml+input_value+ is of type
\ml+'a+ for every type \ml+'a+. The value returned by \ml+input_value+ belongs
to a precise type, and not to all possible types, but the type of this value
cannot be determined at compile time given it depends on the content of the file
being read in. The correct typing of \ml+input_value+ requires an extension to
the ML language known as dynamic objects: these are values paired with a
representation of there type thus enabling run time type checking. Refer to
\cite{Dynamic} for a more detailed presentation.

\subsection*{Remote Procedure Call}

\begin{myfigure}
\begin{myimage}[width="80\%"]
\begin{tikzpicture}
[box/.style={draw, rectangle, inner sep=2mm,rounded corners}]

\node (Sys1) at (0,0) [box, minimum width=30mm] {System};
\node (Rpc1) at (0,1.5) [box] {RPC Server};
\node (User1) at (1,2.75) [box] {User 1};
\node (User2) at (-1,3.5) [box] {User 2};
\node (M1label) at (0,4.5) {Machine A};
\node (M1) [box,fit=(Sys1)(Rpc1)(User1)(User2)(M1label)] {};
\draw [<->] (Sys1) to (Rpc1);
\draw [<->] (Rpc1) to (User1);
\draw [<->] (Rpc1) to (User2);

\node (Sys2) at (5.5,0) [box, minimum width=30mm] {System};
\node (Rpc2) at (5.5,1.5) [box] {RPC Server};
\node (Callf) at (4.5,2.75) [box] {Call f};
\node (Callg) at (6.5,3.5) [box] {Call g};
\node (M2label) at (5.5,4.5) {Machine B};
\node (M2) [box,fit=(Sys2)(Rpc2)(Callf)(Callg)(M2label)] {};
\draw [<->] (Sys2) to (Rpc2);
\draw [<->] (Rpc2) to (Callf);
\draw [<->] (Rpc2) to (Callg);

\draw [<->] (Sys1.east) to (Sys2.west);
\draw [<-, dashed] (User1) to [bend right=8] (Callf);
\draw [->, dashed] (User1) to [bend left=8] (Callf);
\draw [<-, dashed] (User2) to [bend right=5] (Callg);
\draw [->, dashed] (User2) to [bend left=5] (Callg);
\end{tikzpicture}
\end{myimage}
\caption{Remote Procedure Call}
\label{fig/rpc}
\end{myfigure}

Another typical application of this type of protocol is remote procedure call
(\textsc{rpc}). A program on machine A wants to run a function \ml+f+ on a
machine B. This, obviously, is not directly possible. This could be programmed
on a case by case basis using a the system to open a connection towards the
machine B, run the call, relay the answer to the machine A and the user.

In practice, since this is a common case, there is an \textsc{rpc} service that
does that. It is a client-server (client on the machine A, server on the machine
B in our example) which receives execution requests the distant machine (B) from
user connects to the \textsc{rpc} server on the remote machine B which calls f
and sends the returned value back to the \textsc{rcpc} client A which in turn
hands it to the user. The point is that another program can call another
function on the machine B (or another machine) by going through the same
server. The work has been shared by the \textsc{rpc} service installed on the
machines A and B.

As far as the user program is concerned all is happening virtually as if they
were doing a simple function call (crosshatched arrow).

\subsection*{\quotes{text} protocols}

Network services where the efficiency of protocol is not crucial often use
another type of protocol: \quotes{text} protocols. Text protocols are in fact
small domain specific command languages. The requests are expressed are command
lines, with the first word identifying the type of the request and the remaining
words the eventual arguments. The answers are also send out as one ore several
lines of text often starting with a numerical code to ease there reading
in. Some protocols of this type:
\begin{center}
\begin{tabular}{lll}
\textsc{smtp} (Simple Mail Transfert Protocol)
&\rfc{821}
&Electronic mail
\\
\textsc{ftp}
(File Transfert Protocol)
&\rfc{959}
&File transfer
\\
\textsc{nttp}
(Network News Transfert Protocol)
&\rfc{977}
&News reading
\\
\http-1.0 (HyperText Transfert Protocol)
& \rfc{1945}
&Web navigation
\\
\http-1.1 (HyperText Transfert Protocol)
& \rfc{2068}
&Web navigation\\
\end{tabular}
\end{center}
The great advantage of those protocols is that the exchanges between the server
and the client are immediately readable by a human being. In particular one can
use \ml+telnet+ to talk to \quotes{directly} to a server of this type\footnote{
  One just needs to run \ml+telnet machine service+, where \ml+machine+ is the
  name of the machine on which the server is running and \ml+service+ is the
  name of the service (\ml+smtp+, \ml+nntp+, etc.).}: the user types the
requests as a client would and the machine displays the responses. This is very
useful while debugging an application. Of course the work involved in coding and
decoding the messages is also more important thus resulting in more resource
usage.

\begin{example}
Here is an example of an interactive dialog with the \textsc{smtp} server. The
lines preceded by~\ifhtmlelse{>>}{$\rightarrow$} go from the client to the
server and are typed in by the user. The lines preceded
by~\ifhtmlelse{<<}{$\leftarrow$} go from the server to the client.
{\ifnothtml{%
   \lstset{language={},literate={{<<}{{$\leftarrow$}}2 {>>}{{$\rightarrow$}}2}}}
\begin{lstlisting}
    pom: telnet margaux smtp
    Trying 128.93.8.2 ...
    Connected to margaux.inria.fr.
    Escape character is '^]'.
<<  220 margaux.inria.fr Sendmail 5.64+/AFUU-3 ready at Wed, 15 Apr 92 17:40:59
>>  HELO pomerol.inria.fr
<<  250 Hello pomerol.inria.fr, pleased to meet you
>>  MAIL From:<god@heavens.sky.com>
<<  250 <god@heavens.sky.com>... Sender ok
>>  RCPT To:<xleroy@margaux.inria.fr>
<<  250 <xleroy@margaux.inria.fr>... Recipient ok
>>  DATA
<<  354 Enter mail, end with "." on a line by itself
>>  From: god@heavens.sky.com (Himself)
>>  To: xleroy@margaux.inria.fr
>>  Subject: Hello!
>>
>>  Is everything ok down there?
>>  .
<<  250 Ok
>>  QUIT
<<  221 margaux.inria.fr closing connection
    Connection closed by foreign host.
\end{lstlisting}}
The commands \ml+HELO+, \ml+MAIL+ and \ml+RCPT+ send the name of the sending
machine, the address of the sender and the address of the recipient. The
\ml+DATA+ command sends the texts. It is followed by a certain number of lines
(the text of the message), finished by a line containing the single character
\quotes{dot}. To avoid ambiguities all the lines of the message beginning by a
dot are transmitted by doubling the initial dot. The additional dot is
suppressed by the server.

The answer are all of the form \quotes{a 3 digits numerical code and a
  comment}. When the client is a program it only takes in account the numeric
code; the comment is strictly for human consumption. The answers in \ml+5xx+
indicate an error; the one in \ml+2xx+ that everything is fine.
\end{example}

\section {Full example: \http requests}

The {\http} protocol (HyperText Transfer Protocol) is essentially used to read
documents over the \quotes{web}. This domain is an endless source of
client-server examples: web page clients or servers, relays acting as
intermediates, virtual servers for clients and delegated clients for servers
often layering in an additional service such as caching filtering \etc.

There are several versions of the {\http} protocol. In order to keep the example
focused on the essential (that is the architecture of clients or relays) we
shall use the simplified protocol inherited of the very first versions of the
protocol. Even though it is a bit dusty it is still understood by most
servers. We shall outline at the end a more modern and expressive version. This
version is more complex but also necessary to do real tools that work on the
web. We will leave the translation of the examples as an exercise for the
reader.

Version 1.0 of the {http} protocol is specified in the \rfc{1945} norm enable
simplified requests of the form:

\begin{lstlisting}
GET $\textit{sp}$ $\textit{uri}$ $\textit{crlf}$
\end{lstlisting}
where \textit{\ml+sp+} represents a whitespace and \textit{\ml+crlf+} the string
\ml+"\r\n"+ (\quotes{return} followed by \quotes{linefeed}). The response to a
simplified request is also simplified: the content of the url is sent directly
without any headers and the end of the request is signaled by the end of file
which closes the connection. This style of request, inherit from the version 0.9
of the protocol, limits the connection to the on-going request.

\subsection*{Fetching an url}

We'll write a \ml+geturl+ program that takes an {\URL} as argument finds it on
the web downloads the resource it points to and prints its content out.

The first task is to analyze the {\URL} to extract the name of the protocol (the
protocol accepted here is \ml+"http"+), the address of the server, the optional
port and the path of the document on the server. We shall use the \ml+Str+
regular expression library for this analysis.
%
\begin{listingcodefile}{url.ml}
open Unix;;

exception Error of string
let error err mes = raise (Error (err ^ ": " ^ mes));;
let handle_error f x = try f x with Error err -> prerr_endline err; exit 2

let default_port = "80";;

type regexp = { regexp : Str.regexp; fields : (int * string option) list; }

let regexp_match r string =
  let get (pos, default) =
    try Str.matched_group pos string
    with Not_found ->
      match default with Some s -> s | _ -> raise Not_found in
  try
    if Str.string_match r.regexp string 0 then
      Some (List.map get r.fields)
    else None
  with Not_found -> None;;

let host_regexp =
  { regexp = Str.regexp "\\([^/:]*\\)\\(:\\([0-9]+\\)\\)?";
    fields = [ 1, None; 3, Some default_port; ] };;

let url_regexp =
  { regexp = Str.regexp "http://\\([^/:]*\\(:[0-9]+\\)?\\)\\(/.*\\)";
    fields = [ 1, None; 3, None ] };;

let parse_host host = match regexp_match host_regexp host with
  | Some (host :: port :: _) -> host, int_of_string port
  | _ -> error host "Ill formed host";;

let parse_url url = match regexp_match url_regexp url with
  | Some (host :: path :: _) -> parse_host host, path
  | _ -> error url "Ill formed url";;
\end{listingcodefile}
%
We can now tackle the sending of the request. In the simplified protocol this is
a trivial task.
%
\begin{listingcodefile}{url.ml}
let send_get url sock =
  let s = Printf.sprintf "GET %s\r\n" url in
  ignore (write sock s 0 (String.length s));;
\end{listingcodefile}
%
Note that the {\URL} can be anything from the address of the server to the
address of the server, the port and path on that server.

Reading the answers is even easier given that the document is simply sent as the
answer without any additional trimming. When the request is wrong the error
message is encoded in a \textsc{html} document. We will just print out the
answer without sorting out the errors from the successful answers. The
transmission is done through the library call \ml+Misc.retransmit+. The heart
of the program establishes the connection with the server.
%
\begin{listingcodefile}{url.ml}
let get_url proxy url fdout =
  let (hostname, port), path = match proxy with
    | None -> parse_url url
    | Some host -> parse_host host, url
  in
  let hostaddr =
    try inet_addr_of_string hostname
    with Failure _ ->
      try (gethostbyname hostname).h_addr_list.(0)
      with Not_found -> error hostname "Host not found"
  in
  let sock = socket PF_INET SOCK_STREAM 0 in
  Misc.try_finalize
    begin function () ->
      connect sock (ADDR_INET (hostaddr, port));
      send_get path sock;
      Misc.retransmit sock fdout
    end ()
    close sock;;
\end{listingcodefile}
%
We wrap this up by analyzing the command line arguments.
%
\begin{codefile}{geturl.ml}
open Unix
open Url
\end{codefile}
%
\begin{listingcodefile}{geturl.ml}
let geturl () =
  let len =  Array.length Sys.argv in
  if len < 2 then
    error "Usage:" (Sys.argv.(0) ^ " [ proxy [:<port>] ] <url>")
  else
    let proxy, url =
      if len > 2 then Some Sys.argv.(1), Sys.argv.(2) else
      None, Sys.argv.(1)
    in
    get_url proxy url stdout;;

handle_unix_error (handle_error geturl) ();;
\end{listingcodefile}

\subsection*{\http relay}

\begin{myfigure}
\begin{myimage}[width="70\%"]
\begin{tikzpicture}[
 server/.style={draw, rectangle, inner sep=2mm,rounded corners},
 client/.style={draw, ellipse}]
\node (Pauillac) at (0,2.5) [server] {pauillac.inria.fr};
\node (Inria) at (0,0) [server] {www.inria.fr};
\node (Kelen) at (5,3) [server] {kelen.polytechnique.fr};
\node (Relay) at (2.5,1) [server] {Relay};

\node (Client1) at (5.5,0) [client] {Browser};
\node (Client2) at (6,1.5) [client] {Other client};

\draw [<->] (Pauillac) to (Relay);
\draw [<->] (Inria) to (Relay);
\draw [<->] (Kelen) to (Relay);
\draw [<->] (Client1) to (Relay);
\draw [<->] (Client2) to (Relay);
\end{tikzpicture}
\end{myimage}
\caption{\http relay}
\label{fig/relais}
\end{myfigure}

We will now will now write an {\http} relay (\emph{proxy}). It is a {\http}
server that treats all {\http} requests by redirecting them to the destination
machine (or another relay...) and forwards the answers back to the calling
machine.
%
We have drawn out the role of a relay in the \ref{fig/relais} figure. When an
{\http} client uses the relay it addresses its requests to the relay rather than
addressing them directly to the various {\http} servers around the world. The
relay has multiple advantages.

A relay can cash the most recent requests or the most frequent requests to
bypass querying the remote server in subsequent requests. This can be used to
avoid overloading the remote server or as a fallback when the connection
fails. A relay can also act as a filter on some pages (remove the adds or the
images \etc). Using a relay can also simplify writing applications by allowing
to interact with a single server for all the web pages in the world.

The \ml+proxy+ command launches the server on the port passed as an argument,
or, if none specified the default {\http} port. We shall re-use the code of the
\ml+get_url+ function (we suppose that the above functions are available in an
\ml+Url+ module). We still have to write the code to analyze the requests and
set up the server.
%
\begin{listingcodefile}{proxy.ml}
open Unix
open Url

let get_regexp =
  { regexp = Str.regexp "^[Gg][Ee][Tt][ \t]+\\(.*[^ \t]\\)[ \t]*\r";
    fields = [ 1, None ] }

let parse_request line = match regexp_match get_regexp line with
  | Some (url :: _) -> url
  | _ -> error line "Ill formed request"
\end{listingcodefile}
% 
The service will be established the server with the \ml+establish_server+
function. We still have to code the handling of connections.
%
\begin{listingcodefile}{proxy.ml}
let proxy_service (client_sock, _) =
  let service () =
    try
      let in_chan = in_channel_of_descr client_sock in
      let line = input_line in_chan in
      let url = parse_request line in
      get_url None url client_sock
    with End_of_file ->
      error "Ill formed request" "End_of_file encountered"
  in
  Misc.try_finalize
    (handle_error service) ()
    close client_sock
\end{listingcodefile}
\label{page/get_url}
%
The program still needs to establish the service.
%
\begin{listingcodefile}{proxy.ml}
let proxy () =
  let http_port =
    if Array.length Sys.argv > 1 then
      try int_of_string Sys.argv.(1)
      with Failure _ -> error Sys.argv.(1) "Incorrect port"
    else
      try (getservbyname "http" "tcp").s_port
      with Not_found -> error "http" "Unknown service"
  in
  let treat_connection s = Misc.double_fork_treatment s proxy_service in
  let addr = ADDR_INET(inet_addr_any, http_port) in
  Misc.tcp_server treat_connection addr;;

handle_unix_error (handle_error proxy) ();;
\end{listingcodefile}

\subsection*{The {\normalfont \http/1.1} protocol}

Simplified requests force to create a connection per request. The simplified
requests force to create one connection per request. This is can be very
inefficient because it is frequent to have several consecutive requests on the
same server (for instance when loading a web page the browser also loads all the
images in the page). The time it takes to establish the connection can easily
exceed the time spend handling the request per se. We shall see in the
\ref{sec/coprocessus}~chapter how to reduce this time by dispatching the
handling of the requests to co-processes rather than child processes.
%
In the following exercises we shall use the protocol
\http/1.1~(\rfc{2068})~protocol which uses complex requests allowing to serve
several requests per connection\footnote{The \http/1.0 protocol already allows
  this type of request on top of simplified requests, but we prefer using the
  \http/1.1 protocol which deals exclusively with complex requests.}

When answering complex requests the server precedes every answer by a header
describing the format of the answer and, short of that, the size of the
transmitted document. The end of the document is no longer signaled by an
end-of-file since it can be deduced by its size. The connection can stay open to
handle more requests. These requests are of the following form:
%
\begin{lstlisting}
GET $\textit{sp}$ $\textit{uri}$ $\textit{sp}$ HTTP/1.1 $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$
\end{lstlisting}
%
The \textit{\ml+header+} defines a list of key-value fields of the following
syntax:
%
\begin{lstlisting}
$\textit{field}$ : $\textit{value}$ $\textit{crlf}$
\end{lstlisting}
%
Superfluous whitespaces are also allowed around of the \ml+':'+ separator. In
fact a whitespace can always be replaced by a tab or a list of whitespaces. The
header fields can also span several lines: in this sole and only case the
\textit {\ml+crlf+} end-of-line lexeme is immediately followed by a whitespace
\textit{\ml+sp+}. Field keys are not case sensitive as well as values in fields
composed of keywords.

Depending on the type of requests some fields are mandatory others are
optional. For instance a \ml+GET+ request must a field indicated the recipient:
%
\begin{lstlisting}
Host : $\textit{hostname}$ $\textit{crlf}$
\end{lstlisting}
%
For this kind of requests the client can specify by using the optional field
\texttt{If-Modified} that the document must only be returned if it has been
modified after a given date.
%
\begin{lstlisting}
If-Modified : $\textit{date}$ $\textit{crlf}$
\end{lstlisting}
%
The number of fields in the \textit{\ml+header+} is not prefixed but indicated
by the end of the header. The end of the header is marked by an empty
line (ended by \textit{\ml+crlf+} characters.)

Here is a full request (every line is finished by an implicit \ml+\n+ coming
straight after the \ml+r+ character):
%
\begin{lstlisting}
GET /~remy/ HTTP/1.1\r
Host:pauillac.inria.fr\r
\r
\end{lstlisting}
%
A response to a complex request is also a complete answer. It is constituted of
a status line, a header and the body of the response.
%
\begin{lstlisting}
HTTP/1.0 $\textit{sp}$ $\textit{status}$ $\textit{sp}$ $\textit{message}$ $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$
$\textit{body}$
\end{lstlisting}
%
The fields of a response header have a the same syntax as the request but the
required and optional fields are different. (They depend on the status of the
response~---~refer to the documentation for a full description of the protocol).

The \textit{\ml{body}} of the answer can be empty, transmitted as a single bloc
or sliced up. In the second case the header has a \ml+Content-Length+
specifying the number of lines as decimal number written out in plain
\textsc{ascii}. In the third case the header has a \ml+Transfer-Encoding+ field
containing the value \ml+chunked+. In this case the body is a set chunks the
last one of these being empty. A chunk is of the form:
%
\begin{lstlisting}
$\textit{size}$ $\textit{[ ; \textit{arg} ]}$ $\textit{crlf}$
$\textit{chunk}$ $\textit{crlf}$
\end{lstlisting}
%
where \textit{\ml+size+} is the size of the chunk in hexadecimal notation. The
part between the square brackets (\textit{\ml+[+} and \textit{\ml+]+}) is
optional and can safely be ignored and \textit{\ml+chunk+} is a slice of the
full answer of the given size. The last zero sized chunk is always of the
following form:
%
\begin{lstlisting}
0 $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$ $\textit{crlf}$
\end{lstlisting}
%
Finally if the \textit{\ml+body+} of the response is empty if the response is
not chunked and does not contain a field \ml+Content-Length+ (for instance a
response to request of type \ml+HEAD+ only contains a header). Here is an
example of an answer:
\begin{lstlisting}
HTTP/1.1 200 OK\r
Date: Sun, 10 Nov 2002 09:14:09 GMT\r
Server: Apache/1.2.6\r
Last-Modified: Mon, 21 Oct 2002 13:06:21 GMT\r
ETag: "359-e0d-3db3fbcd"\r
Content-Length: 3597\r
Accept-Ranges: bytes\r
Content-Type: text/html\r
\r
<html>
...
</html>
\end{lstlisting}
The status \ml+200+ indicates that a requests was successful. A \ml+301+ or
\ml+401+ means the URL was redirected to another URL defined in the
\ml+Location+ field of the response. The \ml+400+, \ml+401+ \etc{} statuses
indicate errors in the syntax of the request or in its fulfillment whilst the
\ml+500+, \ml+501+, \etc{} statuses errors on the server side while processing
the request.

\begin{exercise}[noanswer]
\label {ex/proxy-1.1}
Write a relay working with \http/1.1 protocol.
\end{exercise}

\begin{exercise}[noanswer]
Add a cache to the relay: the pages are saved on the hard drive. When a
requested page is available in the cache it is served excepted if it is too old
(in which case the server is queried and the cache is updated).
\end{exercise}

\begin{exercise}[noanswer]
\label {ex/wget}
Write a program \ml+wget+ such that \ml+wget u1 .. un+runs the requests \ml+u1+
...\ml+un+ and saves the responses in the files \ml+./m1/p1+ ... \ml+./mn/pn+
where \ml+mi+ and \ml+pi+ are the name of the server and absolute path of the
request \ml+ui+. We shall take advantage of the protocol to establish only one
connection on the machine \ml+m+ when it is the same for consecutive
requests. Further we shall follow {\URL} in case of a redirection.
%
The following options can be added:
\begin{mltypecases}
\mltypecase{-N} to download the {\URL} only the file \ml+./mi/ui+ doesn't exists
or is older than the {\URL}.

\mltypecase{-r} to download recursively all the {\URL}s embedded in the
responses which are HTML documents.
\end{mltypecases}
\end{exercise}


%%%% This is commented in the french version.

%% \begin{answer}
%% Il n'y a pas de difficult particulire dans cette exercice, mais
%% l'analyse des rponses doit tre mticuleuse, car le non respect du
%% protocole peut produite une perte de synchronisation entre le serveur
%% et le client qui ne se comprennent plus. De plus, ces erreurs peuvent
%% tre difficile  dcouvrir, car la plupart des serveurs fournissent
%% des rponses  un format \quotes{standard} alors que le protocole
%% permet plus de flexibilit.

%% Le formattage des requtes quant  lui est immdiat.
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% open Unix
%% open Url
%% let http_version = "HTTP/1.1";;
%% let send chan header =
%%   let send_line line =
%%     output_string chan (String.concat " " line);
%%     output_string chan "\r\n" in
%%   List.iter send_line header;
%%   output_string chan "\r\n";
%%   flush chan;;

%% let send_get chan hostname path =
%%   send chan
%%     [ [ "GET"; path; http_version; ];
%%       ["Host:"; hostname; ];
%%     ];;
%% \end{listingcodefile}
%% %
%% L'analyse des enttes des rponses est une partie facile mais peu
%% intressante. On laisse au lecteur le soin d'crire des fonctions
%% d'analyse:
%% %
%% \begin{lstlisting}
%% val parse_command : in_channel -> (string * string) list
%% val parse_response : in_channel -> (int * string) * (string * string) list
%% val parse_chunk : in_channel -> int * (string * string) list
%% val parse_crlf : in_channel -> unit
%% val tokenize : string -> string list
%% \end{lstlisting}
%% %
%% L'appel \ml+parse_header chan+ lit une suite de champs (les noms
%% champs de champs sont transforms en lettre minuscules).  L'appel
%% \ml+parse response chan+ lit une rponse complte retourne le statut
%% de la rponse (entier), le message et la liste de champs.  L'appel
%% \ml+parse chunk chan+ lit l'entte d'une tranche et retourne sa taille
%% suivit de la liste des champs. L'appel \ml+parse_crlf chan+ lit
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% open Http;;

%% type connection =
%%   { in_chan : in_channel; out_chan : out_channel;
%%     mutable on : bool; host : string; }

%% type header =
%%   { status : int; message : string; fields : (string * string) list }

%% type response =
%%   { connection : connection; header : header };;

%% let read_response connection =
%%   let (c, mes), lines = parse_response connection.in_chan in
%%   { connection = connection;
%%     header = { status = c; message = mes; fields = lines; };
%%   };;
%% \end{listingcodefile}
%% %
%% La copie du corps de la rponse doit tre modifie pour s'arrter sur
%% la taille et non plus sur la fin de fichier.
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% let print_header chan header =
%%   let pr (x, y) =
%%     output_string chan (String.capitalize x); prerr_string ": ";
%%     output_string chan y;
%%     output_string chan "\r\n" in
%%   List.iter pr header;;
%% let error_report err mes reply =
%%   prerr_newline();
%%   print_header Pervasives.stderr [err, mes]; prerr_newline();
%%   print_header Pervasives.stderr reply.header.fields;
%%   error err mes;;
%% let print_chunk chan len =
%%   Printf.fprintf chan "%x\r\n" len;;
%% let print_status chan code mes =
%%   Printf.fprintf chan "%s %d %s\r\n" http_version code mes;;
%% \end{listingcodefile}
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% type echo = Everything | Body | Nothing
%% let response_OK = 200;;
%% let temp_redirect = 301;;
%% let perm_redirect = 302;;
%% let field name reply =
%%   try Some (List.assoc name reply.header.fields) with Not_found -> None
%% let content_length reply : int option =
%%   match field "content-length" reply with
%%     None -> None
%%   | Some s ->
%%       try Some (int_of_string s)
%%       with x -> error "Ill-formed field" "content-length";;

%% let moved reply =
%%   let s = reply.header.status in
%%   s = temp_redirect || s = perm_redirect;;
%% let location reply =
%%   field "location" reply;;
%% let chunked reply =
%%   match field "transfer-encoding" reply with
%%   | Some arg -> List.mem "chunked" (tokenize arg)
%%   | _ -> false;;

%% let buffer_size = 2048;;
%% let buffer = String.create buffer_size;;
%% let rec copy_region echo chan_in chan_out len =
%%   if len > 0 then
%%     let n = input chan_in buffer 0 (min len buffer_size) in
%%     if echo <> Nothing then output chan_out buffer 0 n;
%%     if n > 0 then copy_region echo chan_in chan_out (len -n)
%%     else error "End_of_file" "encountered prematurately";;

%% let rec copy_chunked echo chan_in chan_out =
%%   let len = parse_chunk chan_in in
%%   if echo = Everything then print_chunk chan_out len;
%%   if len > 0 then begin
%%     copy_region echo chan_in chan_out len;
%%     parse_crlf chan_in;
%%     if echo = Everything then output_string chan_out "\r\n";
%%     copy_chunked echo chan_in chan_out
%%   end else
%%     let h = parse_header chan_in in
%%     if echo = Everything then print_header chan_out h;;

%% let transfer echo reply out =
%%   match content_length reply with
%%     Some len ->
%%       copy_region echo reply.connection.in_chan out len
%%   | None when chunked reply ->
%%       copy_chunked echo reply.connection.in_chan out
%%   | None -> ();;

%% let dir_mode = 0o777;;
%% open Filename
%% let mkpath p =
%%   let normal_path =
%%     if basename p = "" then dirname p else p in
%%   let path_to_dir = dirname normal_path in
%%   let rec make p =
%%     try ignore (stat p)
%%     with Unix_error (ENOENT, _, _) ->
%%       if p = current_dir_name then ()
%%       else if p = parent_dir_name then
%%         error "Ill formed path" "contains \"..\""
%%       else begin
%%         make (dirname p);
%%         mkdir p dir_mode
%%       end in
%%   make path_to_dir;;
%% let unwind_protect f x g y =   try f x; g y with x -> g y; raise x;;

%% let regular path =
%%   try (stat path).st_kind = S_REG with Not_found -> false;;
%% let directory path =
%%   try (stat path).st_kind = S_DIR with Not_found -> false;;

%% let transfer_to_file connection file =
%%   let file =
%%     if basename file = "" then concat file "index.html" else file in
%%   mkpath file;
%%   Printf.fprintf Pervasives.stderr " ==> %s\n" file;
%%   let chan_out = Pervasives.open_out file in
%%   unwind_protect (transfer Body connection) chan_out
%%     close_out chan_out;;

%% let close_connection c =
%%   if c.on then begin shutdown_connection c.in_chan; c.on <- false end;;

%% let rec wget_url connection url =
%%   Printf.fprintf Pervasives.stderr "%s" url; flush Pervasives.stderr;
%%   let (hostname, port), path = parse_url url in
%%   let connection =
%%     match connection with
%%       Some c when c.on && c.host = hostname -> c
%%     | Some c when close_connection c; false -> assert false
%%     | _ ->
%%         let hostaddr =
%%           try inet_addr_of_string hostname
%%           with Failure _ -> (gethostbyname hostname).h_addr_list.(0) in
%%         let reply, request = open_connection (ADDR_INET (hostaddr, port)) in
%%         { in_chan = reply; out_chan = request;
%%           on = true; host = hostname; }
%%   in
%%   let get file =
%%     send_get connection.out_chan hostname file;
%%     let reply = read_response connection in
%%     if reply.header.status = response_OK then
%%       begin
%%         transfer_to_file reply (hostname ^ file);
%%         Some connection
%%       end
%%     else if moved reply then
%%       match location reply with
%%         Some new_url ->
%%           transfer Nothing reply Pervasives.stdout;
%%           Printf.fprintf Pervasives.stderr " --> %s\n" new_url;
%%           wget_url (Some connection) new_url
%%       | None ->
%%           error_report "Ill formed answer" "missing location" reply
%%     else error_report (string_of_int reply.header.status)
%%         reply.header.message reply in
%%   handle_syntax_error get path;;
%% \end{listingcodefile}
%% \begin{listingcodefile}{wget.ml}
%% open Sys
%% open Unix
%% open Url
%% open Wgetlib
%% let wget () =
%%   let argn = Array.length Sys.argv in
%%   if argn > 1 then
%%     let argv = Array.sub Sys.argv 1 (argn - 1) in
%%     match Array.fold_left wget_url None argv with
%%       Some c -> close_connection c
%%     | None -> ();;

%% handle_unix_error (handle_error wget) ();;
%% \end{listingcodefile}
%% \end{answer}
