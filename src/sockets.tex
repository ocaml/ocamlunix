%------------------------------------------------------------------------------
% Copyright (c) !!COPYRIGHTYEAR!!, Xavier Leroy and Didier Remy.
%
% All rights reserved. Distributed under a creative commons
% attribution-non-commercial-share alike 2.0 France license.
% http://creativecommons.org/licenses/by-nc-sa/2.0/fr/
%
% Translation by Till Varoquaux, Priya Hattiangdi and Prashanth Mundkur
%------------------------------------------------------------------------------

\chapter{Modern communication: sockets}
\label{sec/sockets}
\cutname{sockets.html}

Communication using pipes presents some limitations. First of all, it
is local to a machine: communicating processes must run on the same
machine (when using named pipes) or even share the pipe's creator as a
common ancestor (when using anonymous pipes). Furthermore, pipes are
not very suitable for a particularly useful model of communication:
the connected or client-server model. In this model, only one program
(the server) has direct access to a shared resource; the other
programs (the clients) access the resource through an intermediary
connection to the server; the server serializes and controls the
accesses to the shared resource. (Example: the \textsc{x}-window
windowing system~---~the shared resources here being the screen, the
keyboard and the mouse.) The client-server model is difficult to
implement with pipes. The major difficulty, here, is the establishment
of the connection between a client and the server. With anonymous
pipes, it is impossible: for the server and the client to have a
common ancestor, it would require an arbitrarily large number of pipes
to be allocated in advance. With named pipes, one could imagine that
the server would read connection requests on a given named pipe, and
these requests would carry the name of another named pipe, created by
the client, which is then used to talk directly to the client. The
problem is ensuring mutual exclusion between simultaneous connection
requests from multiple clients.

Sockets are a generalization of pipes addressing these issues. The
client-server model (in connection-oriented mode) is shown in
figure~\ref{fig/client-server}.

\begin{myfigure}
\begin{myimage}[width="70\%"]
\begin{tikzpicture}
[port/.style={draw,fill,circle,minimum size=1mm,inner sep=0mm},
 server/.style={draw, rectangle, inner sep=2mm,rounded corners},
 client/.style={draw, ellipse}]
\node (V) at (0,4) [server] {Server $V$};
\node (Vp1) at (V.-8) [port] {};
\node (Vp2) at (V.8) [port] {};
\node (U) at (-1,2) [server] {Server $U$};
\node (Up1) at (U.-8) [port] {};
\node[below right] at (Up1.east) {(1)}; % because of babel french

\node (Up2) at (U.8) [port] {};

\node (W) at (0,0) [server] {Server $W$};
\node (Wp1) at (W.-8) [port] {};
\node (Wp2) at (W.8) [port] {};

\node (A) at (5,3) [client] {Client $A$};
\node (Ap) at (A.west) [port] {};

\node (B) at (5,1) [client] {Client $B$};
\node (Bp) at (B.west) [port] {};

\draw [<->] (Up1) to [bend right=15] node[below]{(2)} (Ap);
\draw [<->,dashed] (Up2) to [bend left=15] node[above]{(3)} (Ap);

\draw [<->] (Vp2) to [bend left=20] node[above]{(5)} (Ap);
\draw [<->] (Wp2) to [bend right=20] node[below]{(6)} (Bp);
\draw [densely dotted] (U.north) to [bend left=20] node[left]{(4)} (V.south);
\draw [densely dotted] (U.south) to [bend right=20] (W.north);
\end{tikzpicture}
\end{myimage}
\caption{Client-Server model}
\label{fig/client-server}
\end{myfigure}

\begin{enumerate}
\item
The server $U$ creates a socket $s$ on a port $p$ known to the clients and
waits for connections on it (1).
%
\item
The client $A$ creates a socket and connects to the server on the port
$p$~(2). The system then allocates a new socket to communicate privately with
the client $A$ (3). In this example, it forks off an auxiliary
server $V$~(4), closes its connection with the client $A$ (represented by the
hashed line) and lets its child $V$ handle the connection with $A$~(5).
%
\item
The server can then accept a new client $B$, establish another
connection handled in parallel by another clone $W$~(6), and so on.
%
\item
The server can close its service by closing the file descriptor
associated with the socket $s$. After a while the system frees the
port $p$ which can then be reused, for example to install another
service.

\end{enumerate}

It is essential in this model that the server $U$ and the client $A$
have established a private connection (3) to communicate until the end
of the connection, without interference from other requests issued by
other clients. For that reason, this mode is referred to as the
\emph{connection-oriented} mode. If the transaction is short the
server could handle the request directly (without forking) through the
connection (3). In this case, the next client must wait for the server
to be available, either because it has finished handling the
connection (3), or because it explicitly handles several connections
via multiplexing.

Sockets also allow a \emph{connectionless} client-server mode.  In
this mode, less frequently used, the server does not establish a
private connection with the client, but responds directly to the
client's requests. We shall briefly comment on this model in
section~\ref {sec/mode-deconnecte}.  In the remainder of this chapter,
we shall mainly describe communication in the \emph{connection-oriented} mode.

\section{Sockets}

The socket mechanism, which is an extension of the pipe mechanism, was
introduced in \textsc{bsd} 4.2, and can now be found on all Unix
machines connected to a network (whether via Ethernet or some other
medium). Firstly, special system calls are provided to establish
connections following the client-server model. Then, sockets enable
local and remote communication between processes in a (nearly)
transparent way. For this, several communication domains are
considered. The communication domain bound to a socket indicates with
whom we can communicate on that socket; it constrains the format of
the address used to designate the communicating peer. Two examples of
domains are:

\begin{itemize}
\item the Unix domain: addresses are names in the file system
  hierarchy of a machine. Communication is limited to processes
  running on that machine (as in the case of named pipes).
%
\item the Internet domain: addresses are comprised of the address of a
  machine on the Internet network (addresses of the form
  \ml+129.199.129.1+, for example), and a service number on that
  machine. Communication is possible between processes running on any
  two machines connected to Internet.\footnote{ The Internet network
    is made of local networks, usually Ethernet networks, connected by
    specialized links. It connects millions of machines world-wide. In
    the Internet domain, there is no difference between programs that
    communicate with a neighboring machine, connected to the same
    Ethernet cable, and that communicate with a machine on the other
    side of the planet, through a dozen routers and a satellite link.}
\end{itemize}
% 
Finally, several communication modes are taken into account. These
modes indicate in particular whether the communication is reliable (no
loss nor duplication of data) and in which form the data is sent and
received (a stream of bytes, or a stream of packets~---~small
delimited blocks of bytes). The mode constrains the protocol used to
transmit data. Here are three examples of possible modes:
%
\smallskip
\begin{center}
\begin{tabular}{l|lll}
         & Stream & Datagram & Segmented packets \\
\hline
Reliable   & yes    & no       & yes \\
Data representation & byte stream & packets & packets \\
\end{tabular}
\end{center}
\smallskip


The \quotes{stream} mode is very similar to communication using pipes.
It is the most widely used mode, in particular when used to
transmit unstructured byte sequences (\emph{e.g.} \ml+rsh+).  The
\quotes{segmented packets} mode structures the transmitted data into packets:
each write delimits a packet, each read reads at most a packet. It is well
suited to communication via messages. The \quotes{datagram} mode is the
closest to the hardware capabilities of an Ethernet network: transmissions
are packet based, and there is no guarantee that a packet will arrive at
destination. It is the most economical mode in terms of network resources. Some
programs use it to transmit data that is not of crucial importance
(\emph{e.g.} \ml+biff+); others, to get more network performance, with the
understanding that they must manage data loss themselves.

%
\section{Socket creation}

The \syscall{socket} system call enables the creation of a new socket:
%
\begin{codefile}{tmpunix.mli}
type socket_domain = Unix.socket_domain
type socket_type = Unix.socket_type
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{socket}$ : socket_domain -> socket_type -> int -> file_descr
\end{listingcodefile}
% 
The result is a file descriptor that represents the new socket. This
descriptor is initially in an \quotes{unconnected} state; in
particular, it is not ready to accept any \ml+read+ or \ml+write+.

The first argument specifies the communication domain to which the
socket is to be bound:
%
\begin{mltypecases}
\mltypecase{PF\_UNIX} the Unix domain
\mltypecase{PF\_INET} the Internet domain
\end{mltypecases}
%
The second argument specifies the desired communication mode:
%
\begin{mltypecases}
\mltypecase{SOCK\_STREAM} byte streams, reliable
\mltypecase{SOCK\_DGRAM}  packets, unreliable
\mltypecase{SOCK\_RAW} direct access to the lower layers of the network
\mltypecase{SOCK\_SEQPACKET} packets, reliable
\end{mltypecases}
% 
The third argument is the number of the communication protocol to
use. It is generally 0, which designates the default protocol, usually
determined by the communication type (typically, \ml+SOCK_DGRAM+ and
\ml+SOCK_STREAM+ are associated with the \textsc{udp} and \textsc{tcp}
protocols).  Other values give access to special protocols. A typical
example: the \textsc{icmp} (\emph{Internet Control Message Protocol}),
which is the protocol used by the \ml+ping+ command to send packets
with automatic return to sender. The numbers for these special
protocols are in the \ml+/etc/protocols+ file or in the \ml+protocols+
table of the \textsc{nis} (\emph{Network Information Service})
information system, if any.  The \syscall{getprotobyname} system call
enables this table to be read in a portable way:
%
\begin{codefile}{tmpunix.mli}
type protocol_entry = Unix.protocol_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{getprotobyname}$ : string -> protocol_entry
\end{listingcodefile}
%
The argument is the name of the desired protocol. The result is a \emph{record}
including, among others, the \ml+p_proto+ field which is the number of the protocol.

\section{Addresses}

Several socket operations use socket addresses. They are values of concrete type
\ml+sockaddr+:
\begin{lstlisting}
type $\libtype{Unix}{sockaddr}$ =
  | ADDR_UNIX of string
  | ADDR_INET of inet_addr * int
\end{lstlisting}
The \ml+ADDR_UNIX (f)+ address is an address in the Unix domain. The
string \ml+f+ is the name of the corresponding file in the machine's
filesystem.

\ml+ADDR_INET (a,p)+ is an address in the Internet domain. The first argument,
\ml+a+, is the Internet address of a machine; the second argument, \ml+p+, is a
service number (\emph{port number}) in this machine.

Internet addresses are represented by the abstract type \ml+inet_addr+. Two
functions enable the conversion of strings of the form \ml+128.93.8.2+ to
values of type \ml+inet_addr+, and vice-versa:
%
\begin{codefile}{tmpunix.mli}
type inet_addr = Unix.inet_addr
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{inet\_addr\_of\_string}$ : string -> inet_addr
val $\indexlibvalue{Unix}{string\_of\_inet\_addr}$ : inet_addr -> string
\end{listingcodefile}
%

Another way to obtain Internet addresses is by consulting the
\ml+/etc/hosts+ table, which associates Internet addresses to host
names. One can consult this table and the \textsc{nis} database using
the \syscall{gethostbyname} library function.  On modern machines,
this function queries the \quotes{name servers} either first or as a
fallback. In the former case the file \ml+/etc/hosts+ is only used as
a last resort.
%
\begin{codefile}{tmpunix.mli}
type host_entry = Unix.host_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{gethostbyname}$ : string -> host_entry
\end{listingcodefile}
%
The argument is the name of the desired machine. The result is a
\emph{record} including, among others, the \ml+h_addr_list+
field, which is an array of Internet addresses: the addresses of the
machine. (The same machine can be connected to multiple networks
under different addresses.)

Regarding the service numbers (\emph{port numbers}), the most
common services are listed in the table \ml+/etc/services+. It can be
read in a portable way using the \syscall{getservbyname} function~:
%
\begin{codefile}{tmpunix.mli}
type service_entry = Unix.service_entry
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{getservbyname}$ : string -> string -> service_entry
\end{listingcodefile}
%
The first argument is the service name (i.e. \ml+ftp+ for FTP servers,
\ml+smtp+ for email, \ml+nntp+ for the News server, \ml+talk+ and
\ml+ntalk+ for the commands of that name, etc.). The second argument
is the name of the protocol: usually \ml+"tcp"+ if the service is
using the \quotes{stream} mode or \ml+"udp"+ if the service uses
the \quotes{datagram} mode. The result of \ml+getservbyname+ is a
record whose \ml+s_port+ field contains the desired number.

\begin{example} To obtain the address of the FTP server
\ml+pauillac.inria.fr+~:
%
\begin{lstlisting}
ADDR_INET((gethostbyname "pauillac.inria.fr").h_addr_list.(0),
          (getservbyname "ftp" "tcp").s_port)
\end{lstlisting}
\end{example}

\section{Connection to a server}

The \syscall{connect} system call establishes a connection with a server at a
given address.
%
\begin{codefile}{tmpunix.mli}
type sockaddr = Unix.sockaddr
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{connect}$ : file_descr -> sockaddr -> unit
\end{listingcodefile}
%
The first argument is a socket descriptor. The second argument is the address of
the server to which we want to connect.

Once the connection is established, one can send data to the server using
\indexvalue{write} on the socket descriptor and receive data originating
from the server with \indexvalue{read}. Sockets behave the same as pipes
for read and write operations: \ml+read+ blocks if no data is available
and can return fewer bytes than requested; if the server closes the
connection \ml+read+ returns 0 and \ml+write+ raises a \ml+SIGPIPE+
signal.

\ml+connect+ binds the socket to a local address chosen by the
system. Sometimes, it is preferable to manually choose this address,
in which case one can call the \ml+bind+ function (see below) before
\ml+connect+.

The \ml+netstat+ command can be used to monitor the current connections in the
shell.

\section{Disconnecting sockets}

There are two ways to disconnect a connection. The first is to call
\indexvalue{close} on the socket. This closes the read and write sides
of the connection, and deallocates the socket. This behavior is
sometimes too abrupt. For instance, a client might want to close the
connection in the client to server direction, in order to indicate an
end-of-file to the server, but still keep the connection open in the
server to client direction, so that the server can finish sending
pending data. The \syscall{shutdown} system call enables this kind of
gradual termination of the connection.
%
\begin{codefile}{tmpunix.mli}
type shutdown_command = Unix.shutdown_command
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{shutdown}$ : file_descr -> shutdown_command -> unit
\end{listingcodefile}
%
The first argument is the descriptor of the socket to close. The second argument
is one of:
\begin{mltypecases}
\mltypecase{SHUTDOWN\_RECEIVE} closes the socket for reading; \ml+write+
on the other end of the connection will raise a \ml+SIGPIPE+ signal.

\mltypecase{SHUTDOWN\_SEND} closes the socket for writing; \ml+read+ on the
other end of the connection returns an end-of-file indicator.

\mltypecase{SHUTDOWN\_ALL} closes the socket for reading and writing;
unlike \ml+close+, the socket itself is not deallocated.
\end{mltypecases}
In fact, the deallocation of a socket can take some time whether done abruptly
or cleanly.


\section{A complete example: the universal client}

We are going to define a \ml+client+ command such that 
\ml+client host port+ establishes a connection with a service numbered
\ml+port+ on the machine named \ml+host+, then sends on the connection
everything it reads from its standard input, and writes on its
standard output everything it receives on the connection.

For instance, the command
\begin{lstlisting}
echo -e 'GET /~remy/ HTTP/1.0\r\n\r\n' | ./client pauillac.inria.fr 80
\end{lstlisting}
connects to the port \ml+80+ of \ml+paulliac.inria.fr+ and sends the
\ml+HTTP+ command requesting the home page \ml+/~remy/+ on this server.

This command is a \quotes{universal} client application insofar as it
factors out the code for connection establishment common to many
clients, while delegating the implementation of the communication
protocol, which is specific to each application program that calls
\ml+client+.

We use a library function \ml+retransmit+ that copies data arriving on one
descriptor to another descriptor. It terminates when the end-of-file is
reached on the input descriptor, without closing the descriptors. Note that
\ml+retransmit+ may be interrupted by a signal.
\begin{codefile}{misc.mli}
val retransmit : file_descr -> file_descr -> unit
(** [retransmit fdin fdout] copies the contents of fdin into fdout, until
it receives end-of-file in fdin. It does not close descriptors at the
end. *)
\end{codefile}
\begin{listingcodefile}{misc.ml}
let retransmit fdin fdout =
  let buffer_size = 4096 in
  let buffer = String.create buffer_size in
  let rec copy() =
    match read fdin buffer 0 buffer_size with
      0 -> ()
    | n -> ignore (write fdout buffer 0 n); copy() in
  copy ();;
\end{listingcodefile}
The serious matters start here.
\begin{listingcodefile}[style=numbers]{client.ml}
open Sys;;
open Unix;;

let client () =
  if Array.length Sys.argv < 3 then begin
    prerr_endline "Usage: client <host> <port>";
    exit 2;
  end;
  let server_name = Sys.argv.(1)
  and port_number = int_of_string Sys.argv.(2) in
  let server_addr =
    try (gethostbyname server_name).h_addr_list.(0)
    with Not_found ->
      prerr_endline (server_name ^ ": Host not found");
      exit 2 in
  let sock = socket PF_INET SOCK_STREAM 0 in
  connect sock (ADDR_INET(server_addr, port_number));
  match fork() with
  | 0 -> $\label{prog:add_signal_ignore}$
      Misc.retransmit stdin sock;
      shutdown sock SHUTDOWN_SEND;
      exit 0
  | _ ->
      Misc.retransmit sock stdout;
      close stdout;
      wait();;

handle_unix_error client ();;
\end{listingcodefile}

We start by determining the Internet address of the server to which we
want to connect. It can be specified (as the first argument of the
command) either in numerical form, or as a host name. The
\ml+gethostbyname+ correctly handles both cases.  In the case of a
symbolic address, the \ml+/etc/hosts+ table is queried and the first
matching entry is returned. In the case of a numerical address, no
checks are performed: a structure is simply allocated for the
requested entry.

Then, we create a socket in the Internet domain with the \quotes{stream} mode
and the default protocol, and connect it to the indicated address.

The process is then cloned using \ml+fork+. The child process copies
the data on its standard input to the socket; once the end of the data
on the standard input is reached, it closes the connection for write,
thus transmitting an end-of-file to the server, and terminates. The
parent process copies the data read on the socket to its standard
output. Once the end of the file is detected on the socket, it
synchronizes with the child process using \ml+wait+, and terminates.

The connection can be closed at the initiative of either the client or
the server.
\begin{itemize}

\item
The client receives an end-of-file on its standard input. The client
(child) then closes the connection in the client to server direction
and terminates. In turn, the server upon receiving the end-of-file on
its standard input, should, after a small amount of processing, close
the connection. On the other end of the socket \ml+sock+, the client
(parent) finally receives an end-of-file on the connection and
terminates normally.

\item
% The original version said that the parent tries to write on the
% socket; however, it is the child that writes on the socket.
The server prematurely closes the connection. The client (child) tries
to write on the socket \ml+sock+ and receives the \ml+sigpipe+ signal
which kills it. It is the expected behaviour. However, the client dies
immediately, without being able to indicate that the connection was
lost. To retrieve this information, one can ignore the \ml+SIGPIPE+
signal with the effect of sending the client an \ml+EPIPE+ error which
will then be handled by the handler \ml+handle_unix_error+: one must
insert the following line after the line~\ref{prog:add_signal_ignore}.
%
\begin{lstlisting}
ignore (signal sigpipe Signal_ignore)
\end{lstlisting}
%
\end{itemize}
If the client, parent or child, exits prematurely the socket will be closed for
reading and writing. If the server detects this information, it closes its
side of the socket, which will in turn be detected by the other part of the
client. Otherwise, the server exits normally and closes the connection. In both
cases we end up in one of the previous scenarios.


\section{Establishing a service}

We have just seen how a client connects to a server; we shall now see
how things work on the server side. The first step is to associate an
address to a socket, thus making it reachable from the outside. This
is the role of the \syscall{bind} system call:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{bind}$ : file_descr -> sockaddr -> unit
\end{listingcodefile}
%
The first argument is the descriptor of the socket; the second, the address to
attribute to it. The \ml+bind+ command can also use a special address
\ml+inet_addr_any+ representing all the available Internet addresses on the
machine (which may be on multiple sub-networks).

As a second step, we then declare that the socket can accept connections via
the \syscall{listen} system call:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{listen}$ : file_descr -> int -> unit
\end{listingcodefile}
% 
The first argument is the socket descriptor. The second indicates
how many incomplete connection requests can be put on hold. This
value, usually of the order several dozens, can go up to several
hundreds for very busy servers. When this number is exceeded,
additional connection requests fail.

Finally, connection requests are received via the \syscall{accept} system call:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{accept}$ : file_descr -> file_descr * sockaddr
\end{listingcodefile}
%
The argument is the socket descriptor. The first part of the result is
a descriptor for a newly created socket connected to the client:
everything written on this descriptor can be read on the socket that
was given by the client as argument to \ml+connect+, and
reciprocally. On the server side, the socket passed as an argument to
\ml+accept+ stays free and can accept more connection requests. The
second part of the result is the address of the connected client. It
can be used to check that the client is authorized to connect; this is
what the \textsc{x} server does for instance (\ml+xhost+ can be used
to add new authorizations), or to establish a second connection from
the server to the client (as \ml+ftp+ does for each file transfer
request).

The general scheme of a \textsc{tcp} server is of the following form
(we define these functions in the \ml+Misc+ library).
%
\begin{codefile}{misc.mli}
val install_tcp_server_socket : Unix.sockaddr -> Unix.file_descr
(** [install_tcp_server_socket sockaddr] creates a socket in the internet
 domain,  binds it to the address [sockaddr], listens to it, and returns
it. *)

val tcp_server :
 (file_descr -> file_descr * sockaddr -> 'a) -> sockaddr -> unit
(** [tcp_server f addr] installs the tcp service [f] at the Internet domain
   address  [addr]. For each connection to the service, the
   function [f] receives the server's socket and the client's
   socket-address pair as parameters. It is the responsibility of  [f] to
   close the client connection when done. *)
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{misc.ml}
let install_tcp_server_socket addr =
  let s = socket PF_INET SOCK_STREAM 0 in $\label{prog:sock_stream}$
  try
    bind s addr; $\label{prog:bind}$
    listen s 10; $\label{prog:listen}$
    s
  with z -> close s; raise z;;

let tcp_server treat_connection addr =
  ignore (signal sigpipe Signal_ignore);
  let server_sock = install_tcp_server_socket addr in
  while true do
      let client = restart_on_EINTR accept server_sock in $\label{prog:accept}$
      treat_connection server_sock client $\label{prog:treat}$
  done;;
\end{listingcodefile}
The function \ml+install_tcp_server+ starts by creating a socket in
the Internet domain with the \quotes{stream} mode and the default
protocol (line~\ref{prog:sock_stream}); it then prepares it to accept
new connection requests on the \emph{port} passed as an argument on
the command line using the \ml+bind+ and \ml+listen+ calls on the
lines~\ref{prog:bind} and~\ref{prog:listen}. Given that this is a
library function, we close the socket cleanly in case of an error in
the \ml+bind+ or \ml+listen+ operations.

The \ml+tcp_server+ function creates the socket with
\ml+install_tcp_server+ and enters an infinite loop, in each iteration
of which it waits for a connection request (\ml+accept+, line
~\ref{prog:accept}) and handles it (line~\ref{prog:treat}). Since this
is a library function, we relaunch the (blocking) \ml+accept+ system
call if it is interrupted. Note that it is \ml+treat_connection+'s
duty to close the \ml+client+ descriptor at the end of the connection,
even including when the connection is abruptly terminated. We ignore
the \ml+sigpipe+ signal triggered by an unexpected disconnect of the
client, an event which raises an \ml+EPIPE+ exception that can be
caught by \ml+treat_connection+ rather than abruptly killing the
process.

The \ml+treat_connection+ function also takes the descriptor of the
server as argument because in case of a \ml+fork+ or \ml+double_fork+
it will need to be closed by the forked child.

Connection handling can be done sequentially, \ie{} by the server itself. In
this case, \ml+treat_connection+ just calls the entirely application-specific
\ml+service+ function, which represents the body of the server and actually
executes the requested service, and ends by closing the connection.
%
\begin{lstlisting}
let service (client_sock, client_addr) =
  (* Handle the client on the descriptor client_sock *)
  (* And when we are done: *)
  close client_descr;;
\end{lstlisting}
%
Hence the helper function (which we add to the \ml+Misc+ library):
\begin{codefile}{misc.mli}
val sequential_treatment :
file_descr -> (file_descr * sockaddr -> unit) ->
file_descr * sockaddr -> unit
(** [sequential_treatment server service client] runs [service] provided
      on server for one client. The server is given by its socket [server]
      and the client is given by its socket-address pair [client]. After
      initialization the service is performed by applying [service] to
      [client]. The treatment is sequential, that is, the function only
      returns when the service is completed. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let sequential_treatment server service client = service client
\end{listingcodefile}

As the server cannot handle any other requests while serving a client,
this scheme is usually reserved for quick services, where the
\ml+service+ function always runs in a short bounded time (for
instance, a \ml+date+ server).
% L'exception \ml+EPIPE+ peut <EA>tre lev<E9>e par un client qui ferme
% pr<E9>matur<E9>ment la connexion, c'est au service de prendre cet aspect
% en compte.  qu'il convient d'ignorer: la requ<EA>te en cours est
% simplement interrompue.  Les autres types d'erreurs devront <EA>tre
% rattrap<E9>es par la fonction \ml+service+.

Most servers delegate the service to a child sub-process: \ml+fork+ is called
immediately after \ml+accept+ returns. The child process handles the
connection. The parent process calls \ml+accept+ again immediately. We
obtain the following library function~:
%
\begin{codefile}{misc.mli}
val fork_treatment :
 file_descr -> (file_descr * sockaddr -> unit) ->
 file_descr * sockaddr -> unit
(** same as [sequential_treament] but the treatment is concurrently
 performed by a forked child process of the server. The parent process
 will have to free the child when completed. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let fork_treatment server service (client_descr, _ as client) =
  let treat () = match fork () with
    | 0 -> close server; service client; exit 0
    | k -> ()
  in
  try_finalize treat () close client_descr;;
\end{listingcodefile}
%
Note that it is essential that the parent close the \ml+client_descr+
descriptor, otherwise the close by the child will not suffice to terminate the
connection; in addition, the parent will quickly find itself out of
descriptors.  The descriptor must be closed in the normal case, but if for
some reason the fork fails~---~the program can eventually decide this is not a
fatal error and maintain the server in service.

% I have changed \ml+sock+ (in the original) to be \ml+server+ in the
% sentence below, after comparing with the code, since I think that
% was what was intended.
Similarly, the child closes the \ml+server+ descriptor on which the
connection request was received before performing the service. For one, it
does not need it.  For another, the server might stop accepting connections
before the child is done handling this connection. The \ml+exit 0+ command is
important since it ensures that the child terminates after the execution of
the service and not run the server code.

We glossed over the collection of child processes that will become zombies,
which we now attend to.  There are two ways to do so. The simple approach is
to have a grandchild process handle the connection using a double fork
technique. % It might be a good idea here to reference
           % section~\ref{double-fork}, which describes this technique
           % in more detail, especially how the grandchild process is
           % reaped.
%
\begin{codefile}{misc.mli}
val double_fork_treatment :
file_descr -> (file_descr * sockaddr -> unit) ->
file_descr * sockaddr -> unit
(** same as [fork_treament] but the treatment is performed after a double
   fork. The forked process will be freed automatically on
   completion. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let double_fork_treatment server service (client_descr, _ as client) =
  let treat () = match fork () with
    | 0 ->
        if fork () <> 0 then exit 0;
        close server; service client; exit 0
    | k ->
        ignore (restart_on_EINTR (waitpid []) k)
  in
  try_finalize treat () close client_descr;;
\end{listingcodefile}
%
However, this approach results in the server losing all control of the
grandchild process. In general, it is preferable for the process handling a
service to belong to the same process group as the server, as this enables the
termination of all the services by killing all the processes from that
group. For this, servers usually keep the previous model and add handling of
the child processes, for instance by installing a \ml+Misc.free_children+
procedure in the handler for the \ml+sigchld+ signal.


\section {Tuning sockets}

Sockets have numerous internal parameters that can be tuned: the size of the
transfer buffer, the size of the minimum transfer, the behavior on closing,
\etc{} These parameters have the types boolean, integer, optional integer, and
floating point. For typing reasons, there are as many \ml+getsockopt+,
\ml+getsockopt_optint+, \ml+getsockopt_float+ primitives to read those
parameters, and the corresponding variants of \ml+setsockopt+. One can read
the documentation of the \ocaml~\libvalue{Unix}{getsockopt} function and its
variants to get a detailed list of those options, as well as the
\textsc{posix} reference for \syscall{getsockopt} for their exact meaning.

For instance, here are two types of tunables that only apply to sockets on the
\ml+INET+ domain of the \ml+SOCK_STREAM+ type. The disconnection of sockets in
the \textsc{tcp} protocol is negotiated, which may take some time. Normally
the \indexvalue{close} call returns immediately, while the system negotiates
the disconnection.
%
\begin{lstlisting}
setsockopt_optint sock SO_LINGER (Some 5);;
\end{lstlisting}
%
This option turns \indexvalue{close} into a blocking operation on the
\ml+sock+, which blocks until all the data issued for send has been actually
transmitted or until a 5 second timeout has expired.
%
\begin{lstlisting}
setsockopt sock SO_REUSEADDR;;
\end{lstlisting}
%
The main effect of the \ml+SO_REUSEADDR+ option is to enable the
\indexvalue{bind} system call to reallocate a socket on a local address for
which communication is in the process of being closed. The risk then is of the
new connection receiving packets destined for the old connection. This option
enables the stop and immediate restart of a server, which is very useful in
testing.

\section{A complete example: the universal server}

We shall now define a \ml+server+ command such that:
%
\begin{lstlisting}
./server port cmd arg1 ... argn
\end{lstlisting}
% 
receives connection requests on the port \ml+port+ and, for each
connection, dispatches \ml+cmd+ with the arguments \ml+arg1 ... argn+,
and pipes the connection on its standard input and standard
output. For instance, if we start
%
\begin{lstlisting}
./server 8500 grep foo
\end{lstlisting}
%
on the \ml+pomerol+ machine, we can now on any machine type
%
\begin{lstlisting}
./client pomerol 8500 < /etc/passwd
\end{lstlisting}
%
with the aforementioned \ml+client+ command, and it displays the same result
as if we had typed
%
\begin{lstlisting}
./grep foo < /etc/passwd
\end{lstlisting}
%
except that \ml+grep+ is executed on \ml+pomerol+, and not on the local machine.

The \ml+server+ command is a universal server in as much as it factors in all
the service establishment code common to many servers, whilst delegating the
implementation of the service and communication protocol specific to each
application or program launched by \ml+server+.
%
\begin{listingcodefile}[style=numbers]{server.ml}
open Sys;;
open Unix;;

let server () =
  if Array.length Sys.argv < 2 then begin
    prerr_endline "Usage: client <port> <command> [arg1 ... argn]";
    exit 2;
  end;
  let port = int_of_string Sys.argv.(1) in
  let args = Array.sub Sys.argv 2 (Array.length Sys.argv - 2) in
  let host = (gethostbyname(gethostname())).h_addr_list.(0) in $\label{prog:gethost}$
  let addr = ADDR_INET (host, port) in
  let treat sock (client_sock, client_addr as client) =
    (* log information *)
    begin match client_addr with
    | ADDR_INET(caller, _) ->
        prerr_endline ("Connection from " ^ string_of_inet_addr caller);
    | ADDR_UNIX _ ->
        prerr_endline "Connection from the Unix domain (???)";
    end;
    (* connection treatment *)
    let service (s, _) =
      dup2 s stdin; dup2 s stdout; dup2 s stderr; close s;
      execvp args.(0) args
    in
    Misc.double_fork_treatment sock service client in
  Misc.tcp_server treat addr;;

handle_unix_error server ();;
\end{listingcodefile}
%
The address given to \ml+tcp_server+ contains the Internet address of the
machine running the program; the usual way to get it (line~\ref{prog:gethost})
is to look for the machine (returned by the \ml+gethostname+ call) in the
\ml+/etc/hosts+ table. In fact, there can in general be several addresses
% The original did not change the font for pauillac below, but that is
% inconsistent.
referencing the same machine. For instance, the address of the \ml+pauillac+
machine is \ml+128.93.11.35+, but we can also access it locally (provided we
are already on the \ml+pauillac+ machine) with the address \ml+127.0.0.1+. To
provide a service on all the addresses pointing to this machine, we can use
the \ml+inet_addr_any+ address.

The handling of the service will be done via a \quotes{double fork} after
having issued some information on the connection. The handling of the service
is done by redirecting the standard input and the two standard outputs to the
socket on which the connection was established and executing the desired
command. (Note that the handling of the service cannot be done sequentially.)

Remark: the connection is closed without any intervention of the
\ml+server+ program.  First case: the client closes its connection in
the client to server direction.  The command dispatched by the server
receives an end-of-file on its standard input. It finishes what it has
to do, and calls \ml+exit+ when it is done. This closes the standard
outputs which are the last descriptors open for writing on the
connection. (The client will then receive the end-of-file on the
connection.) Second case: the client ends prematurely and closes the
connection in the server to client direction. The server might then
receive the \ml+sigpipe+ signal while trying to send data to the
client, which can cause the death of the server-side command; this is
perfectly acceptable since nothing is reading the output of this
command.

Finally, the server-side command can exit (either voluntarily or via a signal)
before having read the end-of-file. The client receives a \ml+SIGPIPE+ signal
(in which case the client will die immediately) or an \ml+EPIPE+ exception (if
the signal is ignored) when it tries to write on the connection.

\subsection*{Precautions}

Writing a server is generally more delicate than a client. Whilst the client
knows the server to which it is connecting, the server knows nothing about its
client. In particular, for public services, the client might be
\quotes{hostile}. The server must guard itself against all pathological cases.

A typical attack is done by opening connections and leaving them open
without transmitting requests: after having accepted the connection the
server is blocked waiting on the socket and remains so while the client stays
connected. The attacker can then saturate the service by opening a lot of
connections. It is important for the server to be robust against such
attacks. Firstly, it must only accept a limited number of simultaneous
connections and refuse further connections, in order to avoid exhausting system
resources. Secondly, it must also terminate connections that remain inactive
for long.
%% Il devra aussi, pouvoir continuer à servir normalement les requêtes en cours
%% indépendemment de l'attaque.

A sequential server handling the connection itself without handing it to child
processes is immediately exposed to this blocking issue: the server will be
unresponsive although it is idle. A solution for a sequential server is to
multiplex the connections, but it can be tricky to implement. The solution
with a parallel server is more elegant, but it would still need to have a
timeout, for example by programming an alarm.


\section{Communication in connectionless mode}
\label{sec/mode-deconnecte}
\subsection*{Reads and writes in connectionless mode}

The \textsc{tcp} protocol used by most connections of \ml+SOCK_STREAM+
type can only work in connection-oriented mode. Conversely, the
\textsc{udp} protocol used by most connections of \ml+SOCK_DGRAM+ type
always works in connectionless mode. That is, there is no connection
established between the two machines.

This type of socket can be used without establishing a prior connection.
For this we use the \syscall{recvfrom} and \syscall{sendto} system calls.
%
\begin{codefile}{tmpunix.mli}
type msg_flag = Unix.msg_flag
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{recvfrom}$ :
  file_descr -> string -> int -> int -> msg_flag list -> int * sockaddr

val $\libvalue{Unix}{sendto}$ :
  file_descr -> string -> int -> int -> msg_flag list -> sockaddr -> int
\end{listingcodefile}
%
Each of these calls return the size of the transferred data. The call
\ml+recvfrom+ also returns the address of the peer.

One can also call \indexvalue{connect} on a socket of type \ml+SOCK_DGRAM+,
but this has no effect (it is known as a pseudo-connection). The effect of the
pseudo-connection is purely local. The address passed as an argument is simply
memorized and becomes the address used for sending and receiving (messages
coming in from another address are ignored).

Sockets of this type can be connected several times to change their target and
disconnected by connecting them to an invalid address, e.g. \ml+0+.  By
contrast, this would generally result in an error on a socket of
\ml+SOCK_STREAM+ type.

\subsection*{Low level reads and writes}

The \syscall{recv} and \syscall{send} generalise the \indexvalue{read} and
\indexvalue{write} system calls respectively (but they only work on socket
descriptors).
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{recv}$ : file_descr -> string -> int -> int -> msg_flag list -> int
val $\libvalue{Unix}{send}$ : file_descr -> string -> int -> int -> msg_flag list -> int
\end{listingcodefile}
%
Their interface is similar to \ml+read+ and \ml+write+ but they also take a list
of flags with the following semantics:
%
\begin{mltypecases}
\mltypecase{MSG\_OOB} to send an exceptional value

\mltypecase{MSG\_DONTROUTE} indicates short-circuiting the default routing table

\mltypecase{MSG\_PEEK} examines the data without reading it.
\end{mltypecases}
%
These primitives may be used in connection-oriented mode instead of \ml+read+ and
\ml+write+ or in pseudo connected mode instead of \ml+recvfrom+ and \ml+sendto+.
\section{High level primitives}

The example of the universal client-server is frequent enough that the
\ml+Unix+ module provides higher level functions to establish and consume
services in a nearly transparent way.
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{open\_connection}$ : sockaddr -> in_channel * out_channel
val $\indexlibvalue{Unix}{shutdown\_connection}$ : Pervasives.in_channel -> unit
\end{listingcodefile}
%
The \ml+open_connection+ function opens a socket to the given address and
creates a pair of input-output channels (from the \ml+Pervasives+ module) on
this socket. The communication with the server is done by writing requests on
the channel open for writing and by reading responses on the channel open for
reading. Since channels are buffered, we must flush the channel in order to
ensure that a request has been sent in its entirety.
%
The client can shutdown the connection abruptly by closing either of the
channels (which will close the socket) or more ``cleanly'' by calling
\ml+shutdown_connection+. (If the server closes the connection, the client
will be notified when it receives an end-of-file on the channel open for
reading.)

In a symmetric fashion, a service can be established with the
\ml+establish_service+ function.
%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{establish\_server}$ :
  (in_channel -> out_channel -> unit) -> sockaddr -> unit
\end{listingcodefile}
%
This primitive takes as arguments a function \ml+f+, used to handle
requests, and the address of the socket on which the service is to be
established.  Each connection to the server creates a new socket (as
does the function \ml+accept+); after being cloned, the child process
creates a pair of input-output channels (from the \ml+Pervasives+
library) and passes them to the function \ml+f+ to handle the
connection. The function \ml+f+ reads the requests on the channel open
for reading and responds to the client on the channel open for
writing. Once the service has been provided (i.e. once \ml+f+ has
returned), the child process closes the socket and exits. If the
client closes the connection cleanly, the child will get an
end-of-file on the channel open for reading. If the client does it
abruptly, the child might receive a \ml+SIGPIPE+ when trying to write
on the closed socket.  As for the parent, it has probably already
handled another request! The \ml+establish_server+ usually never
terminates, except in case of an error (e.g. of the {\ocaml} runtime
or the system during the establishment of the service).

\section{Examples of protocols}

In the simple cases (\ml+rsh+, \ml+rlogin+, \ldots), the data transmitted
between the client and the server are naturally seen as byte streams, one from
the client to the server, and the other from the server to the client. In such
cases, the communication protocol is obvious. In other cases, the data to
transmit is more complex, and requires encoding before being transmitted in
the form of a byte stream on the socket. The client and the server must then
agree on the precise transmission protocol, which specifies the format of
requests and responses exchanged on the socket. Most protocols used by Unix
commands are specified in documents called \quotes{\textsc{rfc}} (request for
comments): these documents start out as proposals open for discussion, and
gradually become standards over time, as users adopt the described
protocol.\footnote{The \textsc{rfc}s are available via anonymous \textsc{ftp}
  on numerous sites. In France:
  \href{ftp://ftp.inria.fr}{\texttt{ftp.inria.fr}}, in the directory
  \href{ftp://ftp.inria.fr/pub/rfc/}{\texttt{rfc}}. The reference site is
  \url{http://www.faqs.org/rfcs/}. }


\subsection*{\quotes{Binary} protocols}

The first family of protocols aims at transmitting the data in a
compact form as close as possible to its in-memory representation, in
order to minimise the conversion work needed, and to make most of the
available network bandwidth. Typical examples of protocols of this
type are: the \textsc{x}-window protocol, which governs the exchanges
between the \textsc{x} server and the \textsc{x} applications, and the
\textsc{nfs} protocol (\rfc{1094}).

Integers or floating point numbers are usually transmitted as the 1,2,4 or 8
bytes of their binary representation. For strings, we send the length of the
string first, in the form of an integer, and then the byte content of the
string. For structured objects (tuples,records), we send the fields in order,
simply concatenating their representations. For structured objects of variable
size (arrays), we first send the number of elements that follow. The client
can easily recreate in memory the structure of the transmitted data, provided
it knows its exact type. When several types of data are likely to be exchanged
on a socket, it is often agreed to send an integer identifying the type of the
following data.

\begin{example}
The \ml+XFillPolygon+ call of the \textsc{x} library, which draws and
colors a polygon, causes a message of the following form to be sent to
the \textsc{x} server:
\begin{itemize}
\item the byte 69 (the code of the \ml+FillPoly+ command)
\item a byte for padding
\item a 16 bit integer specifying the number $n$ of vertices of the polygon
\item a 32 bit integer identifying the window on which to draw
\item a 32 bit integer identifying the \quotes{graphic context}
\item a \quotes{form} byte, indicating whether the polygon is convex, etc.
\item a byte indicating whether the coordinates of the vertices are absolute or
  relative
\item $4n$ bytes coding the coordinates of the polygon's vertices,
  with two 16 bit integers for each vertex.
\end{itemize}
\end{example}

In this type of protocol, one must be wary of architecture differences
between the communicating machines. In particular, in the case of
multi-byte integers, some machines put the most significant byte first
(that is, in memory, at the lower-address) (called \emph{big-endian}
architectures), and others put the least significant byte first
(called \emph{little-endian} architectures). For instance, the 16 bit
integer $12345 = 48 \times 256 + 57$ is represented by the byte $48$
at the address $n$ and the byte $57$ at the address $n+1$ on a
big-endian architecture, and by the byte $57$ at the address $n$ and
the byte $48$ at the address $n+1$ on a little-endian
architecture. The protocol must specify for example that all the whole
multi-bytes are transmitted in big-endian mode. Another possibility is
to let the sender choose freely between big-endian and little-endian,
and have it specify in the header of the message which convention it
will use.

The {\ocaml} system helps this task of data formatting (often called
\emph{marshalling} or \emph{serialization} in the literature) by providing two
primitives to convert an {\ocaml} value into a series of bytes, and vice versa:
%
\begin{listingcodefile}{tmppervasives.mli}
val $\indexlibvalue{Pervasives}{output\_value}$ : out_channel -> 'a -> unit
val $\indexlibvalue{Pervasives}{input\_value}$ : in_channel -> 'a
\end{listingcodefile}
%
The aim of those two primitives is to enable saving any structured object to a
disk file, and then restoring it; but they are equally applicable to the
transmission of any object through a pipe or a socket. These primitives can
handle any kind of {\ocaml} object except for functions: they preserve sharing
and circulariies inside transmitted objects; and they can communicate between
architectures of different \emph{endianness}.

\begin{example}
If \textsc{x}-window were written in {\ocaml}, we would have a concrete type
\ml+request+ representing requests that can be sent to the server, and another
concrete type \ml+reply+ of eventual server responses:
%
\begin{lstlisting}
type request =
    ...
  | FillPolyReq of (int * int) array * drawable * graphic_context
                                    * poly_shape * coord_mode
  | GetAtomNameReq of atom
  | ...
and reply =
    ...
  | GetAtomNameReply of string
  | ...
\end{lstlisting}
%
The core of the server would be a loop reading and decoding requests in the
form below:
%
\begin{lstlisting}
(* Get a connection request on the descriptor s *)
let requests = in_channel_of_descr s
and replies  = out_channel_of_descr s in
try
  while true do
    match input_value requests with
        ...
      | FillPoly(vertices, drawable, gc, shape, mode) ->
          fill_poly vertices drawable gc shape mode
      | GetAtomNameReq atom ->
          output_value replies (GetAtomNameReply(get_atom_name atom))
      | ...
  done
with End_of_file ->
  (* end of the connection *)
\end{lstlisting}
%
The \textsc{x} library, linked with each application, would be of the form:
%
\begin{lstlisting}
(* Establish a connection with the server on the descriptor s *)
let requests = out_channel_of_descr s
and replies  = in_channel_of_descr s;;
let fill_poly vertices drawable gc shape mode =
  output_value requests
               (FillPolyReq(vertices, drawable, gc, shape, mode));;
let get_atom_name atom =
  output_value requests (GetAtomNameReq atom);
  match input_value replies with
    GetAtomNameReply name -> name
  | _ -> fatal_protocol_error \ml+get_atom_name+;;
\end{lstlisting}
\end{example}

Note the type of \ml+input_value+ given above is semantically
incorrect because it is far too general: it is not true that the
result of \ml+input_value+ is of type \ml+'a+ for every type
\ml+'a+. The value returned by \ml+input_value+ belongs to a precise
type, and not to all possible types; but the type of this value cannot
be determined at compile time given it depends on the content of the
file being read at runtime. The correct typing of \ml+input_value+
requires an extension to the ML language known as dynamic objects:
these are values paired with a representation of their type, enabling
type checking at runtime. Refer to \cite{Dynamiques} for a more
detailed presentation.

\subsection*{Remote Procedure Call}

\begin{myfigure}
\begin{myimage}[width="80\%"]
\begin{tikzpicture}
[box/.style={draw, rectangle, inner sep=2mm,rounded corners}]

\node (Sys1) at (0,0) [box, minimum width=30mm] {System};
\node (Rpc1) at (0,1.5) [box] {RPC Server};
\node (User1) at (1,2.75) [box] {User 1};
\node (User2) at (-1,3.5) [box] {User 2};
\node (M1label) at (0,4.5) {Machine A};
\node (M1) [box,fit=(Sys1)(Rpc1)(User1)(User2)(M1label)] {};
\draw [<->] (Sys1) to (Rpc1);
\draw [<->] (Rpc1) to (User1);
\draw [<->] (Rpc1) to (User2);

\node (Sys2) at (5.5,0) [box, minimum width=30mm] {System};
\node (Rpc2) at (5.5,1.5) [box] {RPC Server};
\node (Callf) at (4.5,2.75) [box] {Call f};
\node (Callg) at (6.5,3.5) [box] {Call g};
\node (M2label) at (5.5,4.5) {Machine B};
\node (M2) [box,fit=(Sys2)(Rpc2)(Callf)(Callg)(M2label)] {};
\draw [<->] (Sys2) to (Rpc2);
\draw [<->] (Rpc2) to (Callf);
\draw [<->] (Rpc2) to (Callg);

\draw [<->] (Sys1.east) to (Sys2.west);
\draw [<-, dashed] (User1) to [bend right=8] (Callf);
\draw [->, dashed] (User1) to [bend left=8] (Callf);
\draw [<-, dashed] (User2) to [bend right=5] (Callg);
\draw [->, dashed] (User2) to [bend left=5] (Callg);
\end{tikzpicture}
\end{myimage}
\caption{Remote Procedure Call}
\label{fig/rpc}
\end{myfigure}

Another typical application of this type of protocol is remote
procedure call (\textsc{rpc}). A user on machine A wants to run a
program \ml+f+ on a machine B. This is obviously not directly
possible. This could be programmed on a case by case basis, using the
system to open a connection to the machine B to execute the call,
relaying the response to the machine A and the user.

In fact, since this is a common situation, there is an \textsc{rpc} service
that does that. It is a client-server (client on the machine A, server on the
machine B, in our example) which receives requests for execution on a distant
machine (B) from a user, connects to the \textsc{rpc} server on the remote
machine B which executes the call of \ml+f+ and sends the returned value back
to the \textsc{rpc} client A which in turn hands it to the user. The point is
that another user can call another function on the machine B (or another
machine) by going through the same RPC server. The work has been shared by the
\textsc{rpc} service installed on the machines A and B.

From the perspective of the user program, everything happens virtually as if it
were a simple function call (hatched arrows).

\subsection*{\quotes{text} protocols}

Network services where the efficiency of the protocol is not crucial often use
another type of protocol: \quotes{text} protocols, which are in fact
small command languages. The requests are expressed in the form of command
lines, with the first word identifying the type of the request and the following
words the eventual arguments. The responses are also in the form of one or more
lines of text, often starting with a numerical code to facilitate the decoding
of the response. Some protocols of this type:
\begin{center}
\begin{tabular}{lll}
\textsc{smtp} (Simple Mail Transfer Protocol)
&\rfc{821}
&Electronic mail
\\
\textsc{ftp}
(File Transfer Protocol)
&\rfc{959}
&File transfer
\\
\textsc{nttp}
(Network News Transfer Protocol)
&\rfc{977}
&News reading
\\
\http-1.0 (HyperText Transfer Protocol)
& \rfc{1945}
&Web navigation
\\
\http-1.1 (HyperText Transfer Protocol)
& \rfc{2068}
&Web navigation\\
\end{tabular}
\end{center}
The great advantage of these protocols is that the exchanges between the
server and the client are immediately readable by a human being. In
particular, one can use \ml+telnet+ to talk \quotes{directly} to a server
of this type\footnote{ One just needs to run \ml+telnet machine service+,
  where \ml+machine+ is the name of the machine on which the server is running
  and \ml+service+ is the name of the service (\ml+smtp+, \ml+nntp+, etc.).}:
one types the requests just as a client would, and one sees the responses
displayed. This greatly facilitates development. Of course, the work involved
in coding and decoding the requests and responses is also more important than
in the case of binary protocols, the message size is also a little larger;
hence resulting in a lower efficiency.

\begin{example}
Here is an example of an interactive dialog with the \textsc{smtp} server. The
lines preceded by~\ifhtmlelse{>>}{$\rightarrow$} go from the client to the
server, and are typed in by the user. The lines preceded
by~\ifhtmlelse{<<}{$\leftarrow$} go from the server to the client.
{\ifnothtml{%
   \lstset{language={},literate={{<<}{{$\leftarrow$}}2 {>>}{{$\rightarrow$}}2}}}
\begin{lstlisting}
    pom: telnet margaux smtp
    Trying 128.93.8.2 ...
    Connected to margaux.inria.fr.
    Escape character is '^]'.
<<  220 margaux.inria.fr Sendmail 5.64+/AFUU-3 ready at Wed, 15 Apr 92 17:40:59
>>  HELO pomerol.inria.fr
<<  250 Hello pomerol.inria.fr, pleased to meet you
>>  MAIL From:<god@heavens.sky.com>
<<  250 <god@heavens.sky.com>... Sender ok
>>  RCPT To:<xleroy@margaux.inria.fr>
<<  250 <xleroy@margaux.inria.fr>... Recipient ok
>>  DATA
<<  354 Enter mail, end with "." on a line by itself
>>  From: god@heavens.sky.com (Himself)
>>  To: xleroy@margaux.inria.fr
>>  Subject: Hello!
>>
>>  Is everything ok down there?
>>  .
<<  250 Ok
>>  QUIT
<<  221 margaux.inria.fr closing connection
    Connection closed by foreign host.
\end{lstlisting}}
The commands \ml+HELO+, \ml+MAIL+ and \ml+RCPT+ transmit the name of
the sending machine, the address of the sender and the address of the
recipient. The \ml+DATA+ command sends the text of the message
itself. It is followed by a certain number of lines (the text of the
message), terminated by a line containing the single character
\quotes{period}. To avoid ambiguity, all the lines of the message
beginning with a period are transmitted by doubling the initial
period. The additional period is suppressed by the server.

The responses are all of the form \quotes{a 3 digit numerical code and
  a comment}. When the client is a program, it only interprets the
numeric code; the comment is for the use of the person who develops
the mail system.  The responses in \ml+5xx+ indicate an error; those
in \ml+2xx+, that everything is fine.
\end{example}

\section{A complete example: {\normalfont \http} requests}

The {\http} protocol (HyperText Transfer Protocol) is primarily used
to read documents over the famous \quotes{web}. This domain is a niche
area of client-server examples: from reading pages on the web or
writing servers, relays placed as intermediaries, virtual servers for
real clients and clients for delegating to real servers, often
providing an additional service such as adding caches, filters \etc

There are several versions of the {\http} protocol. In order to
focus on the essential, namely the architecture of clients or relays, we
shall use the simplified protocol, present in all the first versions of the
protocol. Even though it is a bit dusty, it is still understood by most
servers. We describe at the end a version that is more modern and expressive,
but also more complex, which is essential to make real tools to explore the
web. However, we will leave the translation of the examples as exercises.

Version 1.0 of the {\http} protocol specified in the \rfc{1945} standard permits
simplified requests of the form:

\begin{lstlisting}
GET $\textit{sp}$ $\textit{uri}$ $\textit{crlf}$
\end{lstlisting}
where \textit{\ml+sp+} represents a space and \textit{\ml+crlf+} the
string \ml+"\r\n"+ (\quotes{return} followed by
\quotes{linefeed}). The response to a simplified request is also
simplified: the content of the {\URL} is sent directly, without any
headers, and the end of the request is signaled by the end-of-file,
which closes the connection. This form of request, inherited from
version 0.9 of the protocol, limits the connection to the current
request.

\subsection*{Fetching a {\URL}}

We propose to write a \ml+geturl+ program that takes a single
argument, a {\URL}, searches the web for the resource it denotes, and
displays it.

The first task is to analyze the {\URL} to extract the name of the
protocol (here, necessarily \ml+"http"+), the address of the server,
the optional port and the absolute path of the document on the
server. We shall use the \ml+Str+ regular expression library to do
this.  We go quickly over the uninteresting but indispensable part of
the code.
%
\begin{listingcodefile}{url.ml}
open Unix;;

exception Error of string
let error err mes = raise (Error (err ^ ": " ^ mes));;
let handle_error f x = try f x with Error err -> prerr_endline err; exit 2

let default_port = "80";;

type regexp = { regexp : Str.regexp; fields : (int * string option) list; }

let regexp_match r string =
  let get (pos, default) =
    try Str.matched_group pos string
    with Not_found ->
      match default with Some s -> s | _ -> raise Not_found in
  try
    if Str.string_match r.regexp string 0 then
      Some (List.map get r.fields)
    else None
  with Not_found -> None;;

let host_regexp =
  { regexp = Str.regexp "\\([^/:]*\\)\\(:\\([0-9]+\\)\\)?";
    fields = [ 1, None; 3, Some default_port; ] };;

let url_regexp =
  { regexp = Str.regexp "http://\\([^/:]*\\(:[0-9]+\\)?\\)\\(/.*\\)";
    fields = [ 1, None; 3, None ] };;

let parse_host host = match regexp_match host_regexp host with
  | Some (host :: port :: _) -> host, int_of_string port
  | _ -> error host "Ill formed host";;

let parse_url url = match regexp_match url_regexp url with
  | Some (host :: path :: _) -> parse_host host, path
  | _ -> error url "Ill formed url";;
\end{listingcodefile}
% 
We can now attack the sending of the request, which, in the
simplified protocol, is a trivial task.
%
\begin{listingcodefile}{url.ml}
let send_get url sock =
  let s = Printf.sprintf "GET %s\r\n" url in
  ignore (write sock s 0 (String.length s));;
\end{listingcodefile}
% 
Note that the {\URL} can contain just the path on the server, or be
complete, also including the port and address of the server.

The reading of the response is even easier, since the document is
simply sent as the response, without any additional information. When
the request is erroneous, the error message is encoded in an
\textsc{html} document. We will just print out the response without
distinguishing whether it indicates an error or is the desired
document. The transmission uses the library function
\ml+Misc.retransmit+. The heart of the program establishes the
connection with the server.
%
\begin{listingcodefile}{url.ml}
let get_url proxy url fdout =
  let (hostname, port), path = match proxy with
    | None -> parse_url url
    | Some host -> parse_host host, url
  in
  let hostaddr =
    try inet_addr_of_string hostname
    with Failure _ ->
      try (gethostbyname hostname).h_addr_list.(0)
      with Not_found -> error hostname "Host not found"
  in
  let sock = socket PF_INET SOCK_STREAM 0 in
  Misc.try_finalize
    begin function () ->
      connect sock (ADDR_INET (hostaddr, port));
      send_get path sock;
      Misc.retransmit sock fdout
    end ()
    close sock;;
\end{listingcodefile}
%
We conclude, as usual, by analyzing the command line.
%
\begin{codefile}{geturl.ml}
open Unix
open Url
\end{codefile}
%
\begin{listingcodefile}{geturl.ml}
let geturl () =
  let len =  Array.length Sys.argv in
  if len < 2 then
    error "Usage:" (Sys.argv.(0) ^ " [ proxy [:<port>] ] <url>")
  else
    let proxy, url =
      if len > 2 then Some Sys.argv.(1), Sys.argv.(2) else
      None, Sys.argv.(1)
    in
    get_url proxy url stdout;;

handle_unix_error (handle_error geturl) ();;
\end{listingcodefile}

\subsection*{{\http} relay}

\begin{myfigure}
\begin{myimage}[width="70\%"]
\begin{tikzpicture}[
 server/.style={draw, rectangle, inner sep=2mm,rounded corners},
 client/.style={draw, ellipse}]
\node (Pauillac) at (0,2.5) [server] {pauillac.inria.fr};
\node (Inria) at (0,0) [server] {www.inria.fr};
\node (Kelen) at (5,3) [server] {kelen.polytechnique.fr};
\node (Relay) at (2.5,1) [server] {Relay};

\node (Client1) at (5.5,0) [client] {Browser};
\node (Client2) at (6,1.5) [client] {Other client};

\draw [<->] (Pauillac) to (Relay);
\draw [<->] (Inria) to (Relay);
\draw [<->] (Kelen) to (Relay);
\draw [<->] (Client1) to (Relay);
\draw [<->] (Client2) to (Relay);
\end{tikzpicture}
\end{myimage}
\caption{{\http} relay}
\label{fig/relais}
\end{myfigure}

We now propose to write an {\http} relay (or \emph{proxy}), which is a
server for {\http} requests that handles all {\http} requests by
redirecting them to the destination machine (or another relay...) and
forwards the responses to the calling machine.
% 
We have illustrated the role of a relay in figure
\ref{fig/relais}. When a {\http} client uses a relay, it addresses its
requests to the relay rather than addressing them directly to the
various {\http} servers located around the world. A relay has multiple
advantages.
% 
A relay can store the most recent requests or the most frequent
requests for later reuse without querying the remote server, either to
avoid overloading it or in the absence of a network connection.  A
relay can also filter specific pages (to remove advertisements or
images, \etc). Using a relay can also simplify writing applications by
allowing interaction with a single server for all the web pages in the
world.

The \ml+proxy+ command launches the server on the port passed as an
argument, or, if it is omitted, the default port for the {\http}
service. We shall reuse the code of the \ml+get_url+ function (we
assume that the above functions, other than the launching of the
command, are available in a \ml+Url+ module). It only remains to write
the code to analyze the requests and set up the server.
%
\begin{listingcodefile}{proxy.ml}
open Unix
open Url

let get_regexp =
  { regexp = Str.regexp "^[Gg][Ee][Tt][ \t]+\\(.*[^ \t]\\)[ \t]*\r";
    fields = [ 1, None ] }

let parse_request line = match regexp_match get_regexp line with
  | Some (url :: _) -> url
  | _ -> error line "Ill formed request"
\end{listingcodefile}
%
We will establish the service with the \ml+establish_server+
command. It suffices then to define the handling of a connection.
%
\begin{listingcodefile}{proxy.ml}
let proxy_service (client_sock, _) =
  let service () =
    try
      let in_chan = in_channel_of_descr client_sock in
      let line = input_line in_chan in
      let url = parse_request line in
      get_url None url client_sock
    with End_of_file ->
      error "Ill formed request" "End_of_file encountered"
  in
  Misc.try_finalize
    (handle_error service) ()
    close client_sock
\end{listingcodefile}
\label{page/get_url}
%
The rest of the program only needs to establish the service.
%
\begin{listingcodefile}{proxy.ml}
let proxy () =
  let http_port =
    if Array.length Sys.argv > 1 then
      try int_of_string Sys.argv.(1)
      with Failure _ -> error Sys.argv.(1) "Incorrect port"
    else
      try (getservbyname "http" "tcp").s_port
      with Not_found -> error "http" "Unknown service"
  in
  let treat_connection s = Misc.double_fork_treatment s proxy_service in
  let addr = ADDR_INET(inet_addr_any, http_port) in
  Misc.tcp_server treat_connection addr;;

handle_unix_error (handle_error proxy) ();;
\end{listingcodefile}

\subsection*{The {\normalfont \http/1.1} protocol}

Simplified requests force the creation of a connection per request,
which can be inefficient, because it is common to have several
consecutive requests to the same server (for instance, loading a web
page containing images will cause subsequent loading of the
corresponding images). The time to establish a connection may easily
exceed the time spent handling the request itself. We shall see in
chapter~\ref{sec/coprocessus} how one can reduce it by handling the
requests with threads rather than processes.
%
In the following exercises, we shall use the
\http/1.1~(\rfc{2068})~protocol which uses complex requests that allow
serving multiple requests per connection.\footnote{The \http/1.0
  protocol already allows such requests in addition to simplified
  requests, but we prefer to describe the \http/1.1 protocol which
  deals exclusively with complex requests.}

With complex requests, the server precedes every response with a
header describing the format of the response and an optional size of
the transmitted document. The end of the document is no longer
indicated by an end-of-file, since it can be deduced from its
size. The connection may stay open to handle more requests. These are
of the following form:
%
\begin{lstlisting}
GET $\textit{sp}$ $\textit{uri}$ $\textit{sp}$ HTTP/1.1 $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$
\end{lstlisting}
%
The \textit{\ml+header+} defines a list of key-value fields of the following
syntax:
%
\begin{lstlisting}
$\textit{field}$ : $\textit{value}$ $\textit{crlf}$
\end{lstlisting}
% 
Superfluous spaces are also allowed around the \ml+':'+
separator. In fact, a space can always be replaced by a tab or a
sequence of spaces. The header fields can also span several lines: in
this case, and in this case only, the \textit {\ml+crlf+} end-of-line
lexeme is immediately followed by a space \textit{\ml+sp+}. Finally,
uppercase and lowercase letters are equivalent in the keyword of
fields and in the values of certain fields composed of keywords.

Depending on the type of request, some fields are mandatory, and
others are optional. For instance, a \ml+GET+ request must have a
field indicating the destination machine:
%
\begin{lstlisting}
Host : $\textit{hostname}$ $\textit{crlf}$
\end{lstlisting}
%
For this type of request, we may also request,  using the optional field
\texttt{If-Modified}, that the document be returned only if it has been
modified since a given date.
%
\begin{lstlisting}
If-Modified : $\textit{date}$ $\textit{crlf}$
\end{lstlisting}
%
The number of fields in the \textit{\ml+header+} is not fixed in
advance but indicated by the end of the header consisting of a line
containing only the characters \textit{\ml+crlf+}.

Here is a complete request (all the lines are terminated by an implicit \ml+\n+
character immediately following the \ml+r+):
%
\begin{lstlisting}
GET /~remy/ HTTP/1.1\r
Host:pauillac.inria.fr\r
\r
\end{lstlisting}
%
A response to a complex request is also a complete response. It contains
a status line, a header, and the body of the response, if any.
%
% The original showed a HTTP/1.0 response, when a HTTP/1.1 response was probably intended.
\begin{lstlisting}
HTTP/1.1 $\textit{sp}$ $\textit{status}$ $\textit{sp}$ $\textit{message}$ $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$
$\textit{body}$
\end{lstlisting}
%
The fields of a response header have a syntax similar to that of a
request but the required and optional fields are different (they
depend on type of request and the status of the response~---~see the
full documentation of the protocol).

The \textit{\ml{body}} of the response can be empty, transmitted in a
single block, or in chunks. In the second case, the header contains a
\ml+Content-Length+ field specifying the number of bytes in decimal
\textsc{ascii} notation. In the third case, the header contains a
\ml+Transfer-Encoding+ field with the value \ml+chunked+. The body is
then a set of chunks and ends with an empty chunk.  A chunk is of the
form:
%
\begin{lstlisting}
$\textit{size}$ $\textit{[ ; \textit{arg} ]}$ $\textit{crlf}$
$\textit{chunk}$ $\textit{crlf}$
\end{lstlisting}
%
where \textit{\ml+size+} is the size of the chunk in hexadecimal notation (the
part between (\textit{\ml+[+} and \textit{\ml+]+}) is
optional and can safely be ignored) and \textit{\ml+chunk+} is a chunk of the
response body of the given size. The last zero sized chunk is always of the
following form:
%
\begin{lstlisting}
0 $\textit{crlf}$
$\textit{header}$ $\textit{crlf}$ $\textit{crlf}$
\end{lstlisting}
%
Finally, the \textit{\ml+body+} of the response is empty when the response is
not chunked and does not contain a \ml+Content-Length+ field (for instance, a
response to a request of type \ml+HEAD+ contains only a header). Here is an
example of an response:
\begin{lstlisting}
HTTP/1.1 200 OK\r
Date: Sun, 10 Nov 2002 09:14:09 GMT\r
Server: Apache/1.2.6\r
Last-Modified: Mon, 21 Oct 2002 13:06:21 GMT\r
ETag: "359-e0d-3db3fbcd"\r
Content-Length: 3597\r
Accept-Ranges: bytes\r
Content-Type: text/html\r
\r
<html>
...
</html>
\end{lstlisting}
The status \ml+200+ indicates that the request was successful. A \ml+301+ or
\ml+401+ means the URL was redirected to another URL defined in the
\ml+Location+ field of the response. The \ml+400+, \ml+401+ \etc{} statuses
indicate errors in the syntax or the result of the request and those of the form
\ml+500+, \ml+501+, \etc{} indicate more serious errors on the server side
while processing the request.

\begin{exercise}[noanswer]
\label {ex/proxy-1.1}
Write a relay that works with the \http/1.1 protocol.
\end{exercise}

\begin{exercise}[noanswer]
Add a cache to the relay: the pages are saved on the hard drive. When a
requested page is available in the cache, it is served, except if it is too old,
in which case the server is queried (and the cache updated).
\end{exercise}

\begin{exercise}[noanswer]
\label {ex/wget}
Write a program \ml+wget+ such that \ml+wget u1 .. un+ makes the
requests \ml+u1+ ...\ml+un+ and saves the responses in the files
\ml+./m1/p1+ ... \ml+./mn/pn+ where \ml+mi+ and \ml+pi+ are the name
of the server and absolute path of the request \ml+ui+
respectively. We shall take advantage of the protocol to establish
only one connection to the machine \ml+m+ when it is the same for
consecutive requests. Further, we shall follow a {\URL} in case of a
temporary or permanent redirection.
%
The following options can be added:
\begin{mltypecases}
\mltypecase{-N} to not download the {\URL} if the file \ml+./mi/ui+
does not exist or is older than the {\URL}.

\mltypecase{-r} to download recursively all the {\URL}s embedded in the
responses which are documents in HTML format.
\end{mltypecases}
\end{exercise}


%%%% This is commented in the french version.

%% \begin{answer}
%% Il n'y a pas de difficulté particulière dans cette exercice, mais
%% l'analyse des réponses doit être méticuleuse, car le non respect du
%% protocole peut produite une perte de synchronisation entre le serveur
%% et le client qui ne se comprennent plus. De plus, ces erreurs peuvent
%% être difficile à découvrir, car la plupart des serveurs fournissent
%% des réponses à un format \quotes{standard} alors que le protocole
%% permet plus de flexibilité.

%% Le formattage des requêtes quant à lui est immédiat.
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% open Unix
%% open Url
%% let http_version = "HTTP/1.1";;
%% let send chan header =
%%   let send_line line =
%%     output_string chan (String.concat " " line);
%%     output_string chan "\r\n" in
%%   List.iter send_line header;
%%   output_string chan "\r\n";
%%   flush chan;;

%% let send_get chan hostname path =
%%   send chan
%%     [ [ "GET"; path; http_version; ];
%%       ["Host:"; hostname; ];
%%     ];;
%% \end{listingcodefile}
%% %
%% L'analyse des entêtes des réponses est une partie facile mais peu
%% intéressante. On laisse au lecteur le soin d'écrire des fonctions
%% d'analyse:
%% %
%% \begin{lstlisting}
%% val parse_command : in_channel -> (string * string) list
%% val parse_response : in_channel -> (int * string) * (string * string) list
%% val parse_chunk : in_channel -> int * (string * string) list
%% val parse_crlf : in_channel -> unit
%% val tokenize : string -> string list
%% \end{lstlisting}
%% %
%% L'appel \ml+parse_header chan+ lit une suite de champs (les noms
%% champs de champs sont transformés en lettre minuscules).  L'appel
%% \ml+parse response chan+ lit une réponse complète retourne le statut
%% de la réponse (entier), le message et la liste de champs.  L'appel
%% \ml+parse chunk chan+ lit l'entête d'une tranche et retourne sa taille
%% suivit de la liste des champs. L'appel \ml+parse_crlf chan+ lit
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% open Http;;

%% type connection =
%%   { in_chan : in_channel; out_chan : out_channel;
%%     mutable on : bool; host : string; }

%% type header =
%%   { status : int; message : string; fields : (string * string) list }

%% type response =
%%   { connection : connection; header : header };;

%% let read_response connection =
%%   let (c, mes), lines = parse_response connection.in_chan in
%%   { connection = connection;
%%     header = { status = c; message = mes; fields = lines; };
%%   };;
%% \end{listingcodefile}
%% %
%% La copie du corps de la réponse doit être modifiée pour s'arrêter sur
%% la taille et non plus sur la fin de fichier.
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% let print_header chan header =
%%   let pr (x, y) =
%%     output_string chan (String.capitalize x); prerr_string ": ";
%%     output_string chan y;
%%     output_string chan "\r\n" in
%%   List.iter pr header;;
%% let error_report err mes reply =
%%   prerr_newline();
%%   print_header Pervasives.stderr [err, mes]; prerr_newline();
%%   print_header Pervasives.stderr reply.header.fields;
%%   error err mes;;
%% let print_chunk chan len =
%%   Printf.fprintf chan "%x\r\n" len;;
%% let print_status chan code mes =
%%   Printf.fprintf chan "%s %d %s\r\n" http_version code mes;;
%% \end{listingcodefile}
%% %
%% \begin{listingcodefile}{wgetlib.ml}
%% type echo = Everything | Body | Nothing
%% let response_OK = 200;;
%% let temp_redirect = 301;;
%% let perm_redirect = 302;;
%% let field name reply =
%%   try Some (List.assoc name reply.header.fields) with Not_found -> None
%% let content_length reply : int option =
%%   match field "content-length" reply with
%%     None -> None
%%   | Some s ->
%%       try Some (int_of_string s)
%%       with x -> error "Ill-formed field" "content-length";;

%% let moved reply =
%%   let s = reply.header.status in
%%   s = temp_redirect || s = perm_redirect;;
%% let location reply =
%%   field "location" reply;;
%% let chunked reply =
%%   match field "transfer-encoding" reply with
%%   | Some arg -> List.mem "chunked" (tokenize arg)
%%   | _ -> false;;

%% let buffer_size = 2048;;
%% let buffer = String.create buffer_size;;
%% let rec copy_region echo chan_in chan_out len =
%%   if len > 0 then
%%     let n = input chan_in buffer 0 (min len buffer_size) in
%%     if echo <> Nothing then output chan_out buffer 0 n;
%%     if n > 0 then copy_region echo chan_in chan_out (len -n)
%%     else error "End_of_file" "encountered prematurately";;

%% let rec copy_chunked echo chan_in chan_out =
%%   let len = parse_chunk chan_in in
%%   if echo = Everything then print_chunk chan_out len;
%%   if len > 0 then begin
%%     copy_region echo chan_in chan_out len;
%%     parse_crlf chan_in;
%%     if echo = Everything then output_string chan_out "\r\n";
%%     copy_chunked echo chan_in chan_out
%%   end else
%%     let h = parse_header chan_in in
%%     if echo = Everything then print_header chan_out h;;

%% let transfer echo reply out =
%%   match content_length reply with
%%     Some len ->
%%       copy_region echo reply.connection.in_chan out len
%%   | None when chunked reply ->
%%       copy_chunked echo reply.connection.in_chan out
%%   | None -> ();;

%% let dir_mode = 0o777;;
%% open Filename
%% let mkpath p =
%%   let normal_path =
%%     if basename p = "" then dirname p else p in
%%   let path_to_dir = dirname normal_path in
%%   let rec make p =
%%     try ignore (stat p)
%%     with Unix_error (ENOENT, _, _) ->
%%       if p = current_dir_name then ()
%%       else if p = parent_dir_name then
%%         error "Ill formed path" "contains \"..\""
%%       else begin
%%         make (dirname p);
%%         mkdir p dir_mode
%%       end in
%%   make path_to_dir;;
%% let unwind_protect f x g y =   try f x; g y with x -> g y; raise x;;

%% let regular path =
%%   try (stat path).st_kind = S_REG with Not_found -> false;;
%% let directory path =
%%   try (stat path).st_kind = S_DIR with Not_found -> false;;

%% let transfer_to_file connection file =
%%   let file =
%%     if basename file = "" then concat file "index.html" else file in
%%   mkpath file;
%%   Printf.fprintf Pervasives.stderr " ==> %s\n" file;
%%   let chan_out = Pervasives.open_out file in
%%   unwind_protect (transfer Body connection) chan_out
%%     close_out chan_out;;

%% let close_connection c =
%%   if c.on then begin shutdown_connection c.in_chan; c.on <- false end;;

%% let rec wget_url connection url =
%%   Printf.fprintf Pervasives.stderr "%s" url; flush Pervasives.stderr;
%%   let (hostname, port), path = parse_url url in
%%   let connection =
%%     match connection with
%%       Some c when c.on && c.host = hostname -> c
%%     | Some c when close_connection c; false -> assert false
%%     | _ ->
%%         let hostaddr =
%%           try inet_addr_of_string hostname
%%           with Failure _ -> (gethostbyname hostname).h_addr_list.(0) in
%%         let reply, request = open_connection (ADDR_INET (hostaddr, port)) in
%%         { in_chan = reply; out_chan = request;
%%           on = true; host = hostname; }
%%   in
%%   let get file =
%%     send_get connection.out_chan hostname file;
%%     let reply = read_response connection in
%%     if reply.header.status = response_OK then
%%       begin
%%         transfer_to_file reply (hostname ^ file);
%%         Some connection
%%       end
%%     else if moved reply then
%%       match location reply with
%%         Some new_url ->
%%           transfer Nothing reply Pervasives.stdout;
%%           Printf.fprintf Pervasives.stderr " --> %s\n" new_url;
%%           wget_url (Some connection) new_url
%%       | None ->
%%           error_report "Ill formed answer" "missing location" reply
%%     else error_report (string_of_int reply.header.status)
%%         reply.header.message reply in
%%   handle_syntax_error get path;;
%% \end{listingcodefile}
%% \begin{listingcodefile}{wget.ml}
%% open Sys
%% open Unix
%% open Url
%% open Wgetlib
%% let wget () =
%%   let argn = Array.length Sys.argv in
%%   if argn > 1 then
%%     let argv = Array.sub Sys.argv 1 (argn - 1) in
%%     match Array.fold_left wget_url None argv with
%%       Some c -> close_connection c
%%     | None -> ();;

%% handle_unix_error (handle_error wget) ();;
%% \end{listingcodefile}
%% \end{answer}
